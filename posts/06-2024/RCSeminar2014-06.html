<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.549">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Christopher Klausmeier; Liang Xu">
<meta name="dcterms.date" content="2024-02-29">

<title>Resource Competition Seminar - 06 – Variable environment and the Droop model with periodic forcing</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<meta name="shinylive:serviceworker_dir" content="../..">
<script src="../../site_libs/quarto-contrib/shinylive-0.2.3/shinylive/load-shinylive-sw.js" type="module"></script>
<script src="../../site_libs/quarto-contrib/shinylive-0.2.3/shinylive/run-python-blocks.js" type="module"></script>
<link href="../../site_libs/quarto-contrib/shinylive-0.2.3/shinylive/shinylive.css" rel="stylesheet">
<link href="../../site_libs/quarto-contrib/shinylive-quarto-css/shinylive-quarto.css" rel="stylesheet">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Resource Competition Seminar</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/xl0418/"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://www.linkedin.com/in/liangxuhuang"> <i class="bi bi-linkedin" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-page-left">
      <h1 class="title">06 – Variable environment and the Droop model with periodic forcing</h1>
                                <div class="quarto-categories">
                <div class="quarto-category">Lecture</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta column-page-left">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Christopher Klausmeier; Liang Xu </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">February 29, 2024</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-full page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#materials" id="toc-materials" class="nav-link active" data-scroll-target="#materials">Materials</a></li>
  <li><a href="#variables-environment" id="toc-variables-environment" class="nav-link" data-scroll-target="#variables-environment">Variables environment</a></li>
  <li><a href="#the-droop-model" id="toc-the-droop-model" class="nav-link" data-scroll-target="#the-droop-model">The Droop model</a></li>
  <li><a href="#nonlinear-averaging-jensens-inequality" id="toc-nonlinear-averaging-jensens-inequality" class="nav-link" data-scroll-target="#nonlinear-averaging-jensens-inequality">Nonlinear averaging (Jensen’s inequality)</a></li>
  <li><a href="#references" id="toc-references" class="nav-link" data-scroll-target="#references">References</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block column-page-left" id="quarto-document-content">





<p>In this session, we discussed how variable environment is considered in the resource competition theory and what the storage model (Droop model) is.</p>
<section id="materials" class="level1">
<h1>Materials</h1>
<p>The video record of the seminar can be found <a href="https://www.youtube.com/watch?v=IQf16WzptkM" target="_blank">HERE</a>.</p>
<p>The slides can be found <a href="https://github.com/xl0418/ResourceCompetitionSeminarPosts-Docs/blob/main/06-2024/Docs/6%20-%20variable%20environments%201.pptx" target="_blank">HERE</a>.</p>
<p>The Mathematica notebook is <a href="https://github.com/xl0418/ResourceCompetitionSeminarPosts-Docs/blob/main/06-2024/Docs/6%20-%20variable%20environments%201.nb" target="_blank">HERE</a>.</p>
</section>
<section id="variables-environment" class="level1">
<h1>Variables environment</h1>
<p>The population growth in a constant environment is often defined as an exponential growth:</p>
<p><span class="math display">\[
\frac{dN}{dt} = rN
\]</span></p>
<p>It can be solved as:</p>
<p><span class="math display">\[
N(t) = N_0 e^{rt}
\]</span></p>
<p>or in a logarithmic form:</p>
<p><span class="math display">\[
\log(N(t)) = \log(N_0) + rt
\]</span></p>
<p>For population growth in a variable environment, the growth rate <span class="math inline">\(r\)</span> is not constant. It can be a function of time. For example, the growth rate can be a step function of time:</p>
<p><span class="math display">\[
r(t) = \begin{cases}
2, &amp; \text{if } t &lt; 1 \\
-1, &amp; \text{if } 1 \leq t &lt; 2 \\
3, &amp; \text{if } t \geq 2
\end{cases}
\]</span></p>
<p>The density can be solved by integrating the growth rate:</p>
<p><span class="math display">\[
\log(N(t)) = \log(N_0) + \int_0^t r(t) dt\\
= \log(N_0) +  \bar{r} t
\]</span></p>
<p>The growth curves in a constant and variable environment are shown in the following figure.</p>
<pre class="shinylive-r" data-engine="r"><code>#| standalone: true
#| viewerHeight: 1000
#| viewerWidth: 800
library(shiny)
library(bslib)
library(plotly)
library(Matrix)


Nt &lt;- function(N0, r, t){
  N0 * exp(r * t)
}

Nt_variable &lt;- function(N0, t1, t2, t3){
  nt_temp &lt;- c()
  for (i in 1:length(t1)){
    nt_temp &lt;- c(nt_temp, N0 * exp(2 * t1[i]))
  }
  nt10 &lt;- nt_temp[length(nt_temp)]
  for (i in 1:length(t2)){
    nt_temp &lt;- c(nt_temp, nt10 * exp( -1 * t2[i]))
  }
  nt20 &lt;- nt_temp[length(nt_temp)]
  for (i in 1:length(t3)){
    nt_temp &lt;- c(nt_temp, nt20 * exp( 3 * t3[i]))
  }
  return(nt_temp)
}


# Define UI for app that draws a histogram ----
# Define UI for app that draws a histogram ----
ui &lt;- fluidPage(
  fluidRow(
    
    tabsetPanel(id = "tabset",
                tabPanel("Population growth in constant environment", 
                         column(4, 
                                div(style="height: 80px;",sliderInput('n0_tab1', HTML("N&lt;sub&gt;0&lt;/sub&gt;"), 0.1, min = 0.01, max = 2))
                         ),
                         column(4,
                                div(style="height: 80px;",sliderInput('r', HTML("r"), 1.1, min = 0.1, max = 10))
                         )
                ),
                tabPanel("Population growth in variable environment",
                         column(4, 
                                div(style="height: 80px;",sliderInput('n0_tab2', HTML("N&lt;sub&gt;0&lt;/sub&gt;"), 0.1, min = 0.01, max = 2))
                         )
                )
    )),
  
  
  
  fluidRow(
    column(12, 
           plotlyOutput("plot1", width=700, height=400),
           plotlyOutput("plot_r", width=700, height=400)
    ))
  
  
)

server &lt;- function(input, output, session) {
  output$plot_r &lt;- renderPlotly({
    if (input$tabset == "Population growth in constant environment") {
      # plot r in time
      t &lt;- seq(0, 3, 0.1)
      r &lt;- input$r
      p &lt;- plot_ly(x = t, y = r, type = 'scatter', mode = 'lines', name = 'r', line = list(color = 'orange', width = 4))
      p
    } else {
      # r is a step function
      t &lt;- seq(0, 3, 0.1)
      r &lt;- c()
      for (i in 1:length(t)){
        if (t[i] &lt; 1){
          r[i] &lt;- 2
        } else if (t[i] &lt; 2 &amp; t[i] &gt;= 1){
          r[i] &lt;- -1
        } else {
          r[i] &lt;- 3
        }
      }
      p &lt;- plot_ly(x = t, y = r, type = 'scatter', mode = 'lines', name = 'r', line = list(color = 'orange', width = 4))
      p
    }
    # xlabel 
    p &lt;- p %&gt;% layout(xaxis = list(title = "Time"), yaxis = list(title = "r"))
    p
    
  })
  
  
  output$plot1 &lt;- renderPlotly({
    if (input$tabset == "Population growth in constant environment") {
      t &lt;- seq(0, 3, 0.1)
      
      nt &lt;-reactive({
        Nt(input$n0_tab1, input$r, t)
      })
      
      gr1 &lt;- data.frame(nt = nt(), t = t)
      # browser()
      p &lt;- plot_ly(data = gr1) %&gt;%
        add_trace(x = ~t, y = ~nt, type = 'scatter', mode = 'lines+markers', name = 'Density')

    } else {
      
      nt &lt;- reactive({
        t1 &lt;- seq(0, 1, 0.1)
        t2 &lt;- seq(0, 1, 0.1)
        t3 &lt;- seq(0, 1, 0.1)
        Nt_variable(input$n0_tab2, t1, t2, t3)
      })
      
      gr2 &lt;- data.frame(nt = nt(), t = c(seq(0, 1, 0.1), 1+seq(0, 1, 0.1), 2+seq(0, 1, 0.1)))
      # browser()
      p &lt;- plot_ly(data = gr2) %&gt;%
        add_trace(x =~t, y = ~nt, type = 'scatter', mode = 'lines+markers', name = 'Density')
    }
    p &lt;- p %&gt;% layout(xaxis = list(title = "Time"), yaxis = list(title = "Density"))
    p
    
  })
  
}
# Create Shiny app ----
shinyApp(ui = ui, server = server)</code></pre>
<p>So, <span class="math inline">\(\bar{r}\)</span> is the appropriate definition of growth / fitness in variable environments for unstructured populations. This is true for any kinds of environmental variation (periodic, random). It is also useful for invasion analysis (coexistence criteria).</p>
<p>However, things become more complicated for structured populations.</p>
<p>Two types of structure:</p>
<p>Extensive structure: Floquet exponents (Klausmeier 2008 Theoretical Ecology), Lyapunov exponents (Metz et al.&nbsp;1992 TREE)</p>
<p>Intensive structure: let intensive variable reach attractor, then calculate growth (Litchman et al.&nbsp;2009 PNAS)</p>
</section>
<section id="the-droop-model" class="level1">
<h1>The Droop model</h1>
<p>The Droop model considers a hirarchical structure of the growth of phytoplankton. Phytoplankton cells take up resources (R) from the environment and convert them into biomass. The conversion rate is regulated by the intracellular nutrient concentration, called cell quota (<span class="math inline">\(Q\)</span>). The growth of cells is then dependent on the cell quota dynamics. The model is defined as</p>
<p><span class="math display">\[
\frac{dN}{dt} = \mu_{\infty} \left(1 - \frac{Q_{min}}{Q}\right) N - mN\\
\frac{dQ}{dt} = v_{max} \frac{R}{R + K} - \mu_{\infty} \left(1 - \frac{Q_{min}}{Q}\right) Q\\
\frac{dR}{dt} = a(R_{in} - R) - v_{max} \frac{R}{R + K}N
\]</span></p>
<p>where <span class="math inline">\(\mu_{\infty}\)</span> is the maximum growth rate, <span class="math inline">\(Q_{min}\)</span> is the minimum cell quota, <span class="math inline">\(m\)</span> is the mortality rate, <span class="math inline">\(v_{max}\)</span> is the maximum uptake rate, <span class="math inline">\(K\)</span> is the half-saturation constant, <span class="math inline">\(R_{in}\)</span> is the resource input, and <span class="math inline">\(a\)</span> is the dilution rate of the resource.</p>
<p>To consider the periodic forcing, we can add a periodic temperature term to the maximum growth rate <span class="math inline">\(\mu_{\infty}\)</span>:</p>
<p><span class="math display">\[
\mu_{\infty} = \mu_0 e^{\mu_1 T}\\
T = T_{mean} + T_{amp} \sin\left(\frac{2\pi t}{\tau}\right)
\]</span></p>
<p>where <span class="math inline">\(\mu_0\)</span> is the maximum growth rate at the mean temperature, <span class="math inline">\(\mu_1\)</span> is the temperature sensitivity, and <span class="math inline">\(T\)</span> is the temperature. The temperature is modeled as a sine function with a mean temperature <span class="math inline">\(T_{mean}\)</span>, an amplitude <span class="math inline">\(T_{amp}\)</span>, and a period <span class="math inline">\(\tau\)</span>.</p>
<p>The behavior of the model is shown in the following figure.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="figures/DroopModel.png" title="Droop" class="img-fluid figure-img"></p>
<figcaption>Illustration of Droop model</figcaption>
</figure>
</div>
<p>You can play the interactive Droop model here:</p>
<pre class="shinylive-r" data-engine="r"><code>#| standalone: true
#| viewerHeight: 1000
#| viewerWidth: 800

Sim_droop &lt;- function(tt, rin, mu0, mu1, vmax, k, temp_mean, temp_amp, tau, qmin, m, n0, r0, q0, y = 1.3) {
  nt &lt;- c(n0)
  rt &lt;- c(r0)
  qt &lt;- c(q0)
  tempt &lt;- c(0)
  mu_t &lt;- c(0)
  for(ti in 1:(tt*100)){
    temp_nt &lt;- nt[ti]
    temp_rt &lt;- rt[ti]
    temp_qt &lt;- qt[ti]

    temp &lt;- temp_mean + temp_amp * sin(2 * pi * ti / tau)
    mu_inf &lt;- mu0 * exp(mu1 * temp)
    v &lt;- vmax * temp_rt / (temp_rt + k)
    
    drt &lt;- ((rin - temp_rt) - v * temp_nt)/100
    dqt &lt;- (v - mu_inf * (1 - qmin / temp_qt) * temp_qt)/100
    dnt &lt;- (mu_inf * (1 - qmin / temp_qt) - m) * temp_nt / 100
    
    temp_rt &lt;- max(temp_rt + drt, 0)
    temp_qt &lt;- max(temp_qt + dqt, 0)
    temp_nt &lt;- max(temp_nt + dnt, 0)
    
  
    nt &lt;- c(nt, temp_nt)
    rt &lt;- c(rt, temp_rt)
    qt &lt;- c(qt, temp_qt)
    tempt &lt;- c(tempt, temp)
    mu_t &lt;- c(mu_t, mu_inf)
  }
  return(data.frame(nt = nt, rt = rt, qt = qt,
                    tempt=tempt, mut = mu_t, cc = 1:(tt*100+1)))
  
}

# Define UI for app that draws a histogram ----
ui &lt;- fluidPage(
  headerPanel(''),
  
  fluidRow(
    column(12,
           textOutput("text"),
           tags$head(tags$style("#text{color: black;
                                 font-size: 30px;
                                 font-style: italic;
                                 }"
           )
           ),
           plotlyOutput("plot1", width=800, height = 400),
           plotlyOutput("plot2", width=800, height = 400)
    )
  ),
  
  fluidRow(
    column(4,
           div(style="height: 80px;",sliderInput('temp_amp', HTML("Temperature amplitude"), 5, min = 0.1, max = 5))
    ),
    column(4,
           div(style="height: 80px;",sliderInput('tau', HTML("Period"), 5, min = 1, max = 50))
    )
  )
  
  
)

server &lt;- function(input, output, session) {
  output$text &lt;- renderText({
    "Droop model + periodic forcing"
  })
  
  
  
  
  # sim lv model
  sim_result &lt;- reactive({
    Sim_droop(tt = 30, rin = 10, mu0 = 1, mu1 = 1, vmax=10, k = 1,
              temp_mean = 0, temp_amp = input$temp_amp, tau = input$tau,
              qmin = 1, m = 0.5, n0 = 1, r0 = 1, q0 = 1)
  })
  # browser()
  
  output$plot1 &lt;- renderPlotly({
    
    p &lt;- plot_ly(data = sim_result()) %&gt;%
      add_trace(x = ~cc, y = ~nt, type = 'scatter', mode = 'lines', name = 'N', line = list(color = 'green')) %&gt;%
      add_trace(x = ~cc, y = ~rt, type = 'scatter', mode = 'lines', name = 'R', line = list(color = 'blue')) %&gt;%
      add_trace(x = ~cc, y = ~qt, type = 'scatter', mode = 'lines', name = 'Q', line = list(color = 'orange')) %&gt;%
      #x limit
      layout(xaxis = list(range = c(0, 1000))) %&gt;%
      # x label
      layout(xaxis = list(title = "Time"),yaxis = list(title = "N"))
    p
    
  })
  
  output$plot2 &lt;- renderPlotly({
    
    p &lt;- plot_ly(data = sim_result()) %&gt;%
      add_trace(x = ~cc, y = ~tempt, type = 'scatter', mode = 'lines', name = 'temp', line = list(color = 'red', width = 4)) %&gt;%
      #x limit
      layout(xaxis = list(range = c(0, 100)))  %&gt;%
      # x label
      layout(xaxis = list(title = "Time"),yaxis = list(title = "Temperature"))
    p
    
  })
  
}
# Create Shiny app ----
shinyApp(ui = ui, server = server)</code></pre>
</section>
<section id="nonlinear-averaging-jensens-inequality" class="level1">
<h1>Nonlinear averaging (Jensen’s inequality)</h1>
<p>The nonlinear averaging is a method to calculate the average of a nonlinear function. For example, the average of the growth rate in a variable environment is defined as:</p>
<p><span class="math display">\[
\bar{r} = \frac{1}{T} \int_0^T r(t) dt
\]</span></p>
<p>where <span class="math inline">\(T\)</span> is the period of the forcing. The average of the growth rate is not equal to the growth rate at the average environment. This is because the growth rate is a nonlinear function of the environment. The nonlinear averaging is important for the population growth in a variable environment.</p>
<p>For example, if the growth rate is a convex curve, the average of the growth rate is less than the growth rate at the average environment. The following figure shows the nonlinear averaging of a convex curve.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="figures/nonlinearav1.png" title="Case 1" class="img-fluid figure-img"></p>
<figcaption>Convex curve and averaging</figcaption>
</figure>
</div>
<p>if the growth rate is a concave curve, the average of the growth rate is greater than the growth rate at the average environment. The following figure shows the nonlinear averaging of a concave curve.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="figures/nonlinearav2.png" title="Case 2" class="img-fluid figure-img"></p>
<figcaption>Concave curve and averaging</figcaption>
</figure>
</div>
<p>Using the Taylor expansion, we can calculate the average of the growth rate as:</p>
<p><span class="math display">\[
\bar{r}(x) = r(\bar{x}) + \frac{1}{2} \left(\frac{d^2r}{dx^2}\right) Var(x)
\]</span></p>
</section>
<section id="references" class="level1">
<h1>References</h1>
<p>Droop, M.R. (1973), SOME THOUGHTS ON NUTRIENT LIMITATION IN ALGAE†. Journal of Phycology, 9: 264-272. https://doi.org/10.1111/j.1529-8817.1973.tb04092.x</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>