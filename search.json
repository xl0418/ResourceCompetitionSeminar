[
  {
    "objectID": "posts/03-2024/RCSeminar2014-03.html",
    "href": "posts/03-2024/RCSeminar2014-03.html",
    "title": "03 – The three-species problem",
    "section": "",
    "text": "Paper discussion: The three-species problem: incorporating competitive asymmetry and intransitivity in modern coexistence theory by Ravi Ranjan, Thomas Koffel, Christopher A. Klausmeier. (Link to the paper will be added soon)\nWe talked about the three species competition. There are many types of competition outcomes. They are determined by the 12 parameters in the model, i.e., the three intrinsic growth rates and 9 pairwise competition coefficients. The authors showed that the outcome of the competition is associated with the cyclic asymmetry, which is a triplet-wise quantity.\n\nPaper Abstract\nWhile natural communities can contain hundreds of species, modern coexistence theory focuses primarily on species pairs. Alternatively, the structural stability approach considers the feasibility of equilibria, gaining scalability to larger communities but sacrificing information about dynamic stability. Three-species competitive communities are a bridge to more-diverse communities. They display novel phenomena while remaining amenable to mathematical analysis, but remain incompletely understood. Here, we combine these approaches to identify the key quantities that determine the outcome of competition. We show that pairwise niche overlap and fitness differences are insufficient to completely characterize competitive outcomes, which requires a strictly triplet-wise quantity: cyclic asymmetry. Low pairwise niche overlap stabilizes the triplet, while high fitness differences promote competitive exclusion. The effect of cyclic asymmetry on stability is complex and depends on pairwise niche overlap. In summary, we elucidate how pairwise niche overlap, fitness differences, and cyclic asymmetry determine the outcome of three-species competition.\n\n\nModel\nThe three-species Lotka-Volterra competition model is defined as\n\\[\n\\begin{aligned}\n\\frac{dN_1}{dt} &=  \\left(r_1 - \\alpha_{11} N_1 - \\alpha_{12} N_2 - \\alpha_{13} N_3\\right) N_1 \\\\\n\\frac{dN_2}{dt} &=  \\left(r_2 - \\alpha_{21} N_1 - \\alpha_{22} N_2 - \\alpha_{23} N_3\\right) N_2 \\\\\n\\frac{dN_3}{dt} &=  \\left(r_3 - \\alpha_{31} N_1 - \\alpha_{32} N_2 - \\alpha_{33} N_3\\right) N_3\n\\end{aligned}\n\\]\nwhere \\(N_1\\), \\(N_2\\) and \\(N_3\\) are the population sizes of species 1, 2 and 3, respectively, \\(r_1\\), \\(r_2\\) and \\(r_3\\) are the intrinsic growth rates, and \\(\\alpha_{ij}\\)s are the competition coefficients.\n\n\nThe simulation\n#| standalone: true\n#| viewerHeight: 700\n#| viewerWidth: 1000\n\nlibrary(shiny)\nlibrary(bslib)\nlibrary(plotly)\nlibrary(Matrix)\n\nSim_lotka_volterra &lt;- function(tt, alpha11, alpha12, alpha13, alpha21, alpha22,\n                               alpha23, alpha31, alpha32, alpha33, r1, r2, r3, N10, N20, N30) {\n  N1 &lt;- c(N10)\n  N2 &lt;- c(N20)\n  N3 &lt;- c(N30)\n  cc &lt;- c(0)\n  for(ti in 1:tt){\n    dN1 &lt;- (r1 - alpha11 * N1[ti] - alpha12 * N2[ti] - alpha13 * N3[ti]) * N1[ti]\n    dN2 &lt;- (r2 - alpha21 * N1[ti] - alpha22 * N2[ti] - alpha23 * N3[ti]) * N2[ti]\n    dN3 &lt;- (r3 - alpha31 * N1[ti] - alpha32 * N2[ti] - alpha33 * N3[ti]) * N3[ti]\n    N1 &lt;- c(N1, N1[ti] + dN1)\n    N2 &lt;- c(N2, N2[ti] + dN2)\n    N3 &lt;- c(N3, N3[ti] + dN3)\n    cc &lt;- c(cc, ti)\n  }\n  return(data.frame(N1 = N1, N2 = N2, N3 = N3, cc = cc))\n  \n}\n\n\n\n\n# Define UI for app that draws a histogram ----\n# Define UI for app that draws a histogram ----\nui &lt;- fluidPage(\n  headerPanel(''),\n  \n  fluidRow(\n    column(12, \n           tags$head(tags$style(\"#text{color: black;\n                                 font-size: 30px;\n                                 font-style: italic;\n                                 }\"\n           )\n           ),\n           plotlyOutput(\"plot\", width=860)\n    )\n  ), \n  \n  fluidRow(\n    column(3, \n           div(style=\"height: 80px;\",sliderInput('r1', 'r1', 1.1, min = 0.1, max = 3)),\n           div(style=\"height: 80px;\",sliderInput('r2', 'r2', 1.1, min = 0.1, max = 3)),\n           div(style=\"height: 80px;\",sliderInput('r3', 'r3', 1.1, min = 0.1, max = 3))\n    ),\n    column(3,\n           div(style=\"height: 80px;\", sliderInput('alpha11', HTML(\"&alpha;&lt;sub&gt;11&lt;/sub&gt;\"), 1.0, min = 0.1, max = 5)),\n           div(style=\"height: 80px;\",sliderInput('alpha12', HTML(\"&alpha;&lt;sub&gt;12&lt;/sub&gt;\"), 0.15, min = 0.1, max = 5)),\n           div(style=\"height: 80px;\",sliderInput('alpha13', HTML(\"&alpha;&lt;sub&gt;13&lt;/sub&gt;\"), 1.9, min = 0.1, max = 5))\n    ),\n    column(3,\n           div(style=\"height: 80px;\",sliderInput('alpha21', HTML(\"&alpha;&lt;sub&gt;21&lt;/sub&gt;\"), 2, min = 0.1, max = 5)),\n           div(style=\"height: 80px;\",sliderInput('alpha22', HTML(\"&alpha;&lt;sub&gt;22&lt;/sub&gt;\"), 1.1, min = 0.1, max = 5)),\n           div(style=\"height: 80px;\",sliderInput('alpha23', HTML(\"&alpha;&lt;sub&gt;23&lt;/sub&gt;\"), 0.2, min = 0.1, max = 5))\n    ),\n    column(3,\n           div(style=\"height: 80px;\",sliderInput('alpha31', HTML(\"&alpha;&lt;sub&gt;31&lt;/sub&gt;\"), 0.15, min = 0.1, max = 5)),\n           div(style=\"height: 80px;\",sliderInput('alpha32', HTML(\"&alpha;&lt;sub&gt;32&lt;/sub&gt;\"), 2.1, min = 0.1, max = 5)),\n           div(style=\"height: 80px;\",sliderInput('alpha33', HTML(\"&alpha;&lt;sub&gt;33&lt;/sub&gt;\"), 1.2, min = 0.1, max = 5))\n    )\n  )\n  \n  \n)\n\nserver &lt;- function(input, output, session) {\n  N1 &lt;- seq(0, 20, 0.01)\n  N2_1 &lt;-reactive({\n    (input$r1 - input$alpha11 * N1) / input$alpha12 \n  })\n  \n  N3_1 &lt;-reactive({\n    (input$r1 - input$alpha11 * N1) / input$alpha13 \n  })\n  \n  N2_2 &lt;- reactive({\n    (input$r2 - input$alpha21 * N1) / input$alpha22\n  })\n  \n  \n  # sim lv model\n  sim_result &lt;- reactive({\n    Sim_lotka_volterra(100, input$alpha11, input$alpha12, input$alpha13,\n                       input$alpha21, input$alpha22, input$alpha23,\n                       input$alpha31, input$alpha32, input$alpha33,\n                       input$r1, input$r2, input$r3, 0.1, 0.1, 0.1)\n  })\n  \n  \n  output$plot &lt;- renderPlotly({\n    Ns &lt;- data.frame(N1 = N1, N2_1 = N2_1(), N2_2 = N2_2())\n    pos_Ns &lt;- Ns[Ns$N2_1 &gt;= 0 | Ns$N2_2 &gt;= 0,]\n    x_lim &lt;- c(0, max(pos_Ns$N1) + 1)\n    y_lim &lt;- c(0, max(pos_Ns$N2_1, pos_Ns$N2_2)+1)\n    p &lt;- plot_ly(sim_result(), x = ~N1, y = ~N2, z = ~N3, type = 'scatter3d',  mode = 'lines+markers',\n                 line = list(width = 6,  color = ~cc, colorscale = list(c(0,'#BA52ED'), c(100,'#FCB040'))),\n                 marker = list(size = 3.5, color = '#56A902'),\n                 width = 500, height = 400)\n      \n    # p &lt;- layout(p, scene = list(xaxis = list(range = c(0, 1.5)), yaxis = list(range = c(0, 2)),\n    #                              zaxis = list(range = c(0, 2))))\n    \n    \n    p\n  })\n  \n}\n# Create Shiny app ----\nshinyApp(ui = ui, server = server)\n\n\nReferences\nRavi Ranjan, Thomas Koffel, Christopher A. Klausmeier, The three-species problem: incorporating competitive asymmetry and intransitivity in modern coexistence theory, 2024, in press."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Resource Competition Seminar 2024",
    "section": "",
    "text": "03 – The three-species problem\n\n\n\n\n\n\nLectures\n\n\n\n\n\n\n\n\n\nFeb 8, 2024\n\n\nChristopher Klausmeier; Liang Xu\n\n\n\n\n\n\n\n\n\n\n\n\n02 – Lotka-Volterra competition model and the modern coexistence theory\n\n\n\n\n\n\nLectures\n\n\n\n\n\n\n\n\n\nFeb 1, 2024\n\n\nChristopher Klausmeier; Liang Xu\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "This seminar is organised by Christopher Klausmeier as the form of an online seminar on resource competition theory and related ecological theories from January 8th to April 15th 2024. The format is a mix of lecture and discussion of classic and recent papers. Some previous exposure to ecological theory an intro grad level (e.g. population growth models & competition theory) is desired.\nThis Blog is developed and maintained by Liang Xu, severing as an online lecture and providing an alternative to the programming illustration by Mathematica for those who cannot access Mathematica. The blog is developed using Quarto and hosted on GitHub. The interactive visulation of the model is developed using R Shiny. If you have any questions or suggestions, please feel free to contact me via Email"
  },
  {
    "objectID": "posts/02-2024/RCSeminar2014.html",
    "href": "posts/02-2024/RCSeminar2014.html",
    "title": "02 – Lotka-Volterra competition model and the modern coexistence theory",
    "section": "",
    "text": "Two-species Lotka-Volterra competition model and the modern coexistence theory are discussed.\n\nTwo-species Lotka-Volterra competition model\nThe two-species Lotka-Volterra competition model is defined as\n\\[\n\\begin{aligned}\n\\frac{dN_1}{dt} &=  \\left(r_1 - \\alpha_{11} N_1 - \\alpha_{12} N_2\\right) N_1 \\\\\n\\frac{dN_2}{dt} &=  \\left(r_2 - \\alpha_{21} N_1 - \\alpha_{22} N_2\\right) N_2\n\\end{aligned}\n\\]\nwhere \\(N_1\\) and \\(N_2\\) are the population sizes of species 1 and 2, respectively, \\(r_1\\) and \\(r_2\\) are the intrinsic growth rates, and \\(\\alpha_{ij}\\)s are the competition coefficients.\nFive types of outcomes are possible:\n\nCase 1: Species 1 wins\nIf \\(r_1 / \\alpha_{11} &gt; r_2 / \\alpha_{21}\\) and \\(r_1 / \\alpha_{12} &gt; r_2 / \\alpha_{22}\\), species 1 will win. The ecosystem will reach equilibrium at \\((r_1 / \\alpha_{11}, 0)\\).\nCase 2: Species 2 wins\nIf \\(r_1 / \\alpha_{11} &lt; r_2 / \\alpha_{21}\\) and \\(r_1 / \\alpha_{12} &lt; r_2 / \\alpha_{22}\\), species 2 will win. The ecosystem will reach equilibrium at \\((0, r_2 / \\alpha_{22})\\).\nCase 3: Coexistence\nIf \\(r_1 / \\alpha_{11} &lt; r_2 / \\alpha_{21}\\) and \\(r_1 / \\alpha_{12} &gt; r_2 / \\alpha_{22}\\), the two species will coexist. The equilibrium point is given by the solution of the following equations:\n\\[\nr_1 - \\alpha_{11} N_1 - \\alpha_{12} N_2 =0 \\\\\nr_2 - \\alpha_{21} N_1 - \\alpha_{22} N_2 =0\n\\]\nCase 4: Founder control\nIf \\(r_1 / \\alpha_{11} &gt; r_2 / \\alpha_{21}\\) and \\(r_1 / \\alpha_{12} &lt; r_2 / \\alpha_{22}\\), the species with a larger density at the initial stage will win. The ecosystem will reach equilibrium at the corresponding species’ equilibrium point.\nCase 5: Neutrality\nIf the two species share all parameters, their zero-net-population-isoclines (ZNGIs) are overlapping.\n\n\n\nThe phase-plane analysis\nThe zero-net growth isoclines are given by:\n\\[\n\\begin{aligned}\n\\frac{dN_1}{dt} &= 0 \\Rightarrow N_1 = \\frac{\\left(r_1 - \\alpha_{12} N_2\\right)}{\\alpha_{11}}  \\\\\n\\frac{dN_2}{dt} &= 0 \\Rightarrow N_2 = \\frac{\\left(r_2 - \\alpha_{21} N_1\\right)}{\\alpha_{22}}\n\\end{aligned}\n\\]\nPlot the isoclines in the phase plane.\nThe equilibrium points are the intersection of the isoclines.\n#| standalone: true\n#| viewerHeight: 700\n#| viewerWidth: 1000\n\nlibrary(shiny)\nlibrary(bslib)\nlibrary(plotly)\nlibrary(Matrix)\n\nSim_lotka_volterra &lt;- function(tt, alpha11, alpha12, alpha21, alpha22, r1, r2, N10, N20) {\n  N1 &lt;- c(N10)\n  N2 &lt;- c(N20)\n  for(ti in 1:tt){\n    dN1 &lt;- (r1 - alpha11 * N1[ti] - alpha12 * N2[ti]) * N1[ti]\n    dN2 &lt;- (r2 - alpha21 * N1[ti] - alpha22 * N2[ti]) * N2[ti]\n    N1 &lt;- c(N1, N1[ti] + dN1)\n    N2 &lt;- c(N2, N2[ti] + dN2)\n  }\n  return(data.frame(N1 = N1, N2 = N2))\n  \n}\n\n\n# Define UI for app that draws a histogram ----\n# Define UI for app that draws a histogram ----\nui &lt;- fluidPage(\n  headerPanel(''),\n  \n  fluidRow(\n    column(12, \n           textOutput(\"text\"),\n           tags$head(tags$style(\"#text{color: black;\n                                 font-size: 30px;\n                                 font-style: italic;\n                                 }\"\n           )\n           ),\n           plotlyOutput(\"plot\", width=860)\n    )\n  ), \n  \n  fluidRow(\n    column(4, \n           div(style=\"height: 80px;\",sliderInput('r1', 'r1', 0.4, min = 0.1, max = 3)),\n           div(style=\"height: 80px;\",sliderInput('r2', 'r2', 1.1, min = 0.1, max = 3))\n    ),\n    column(4,\n           div(style=\"height: 80px;\", sliderInput('alpha11', HTML(\"&alpha;&lt;sub&gt;11&lt;/sub&gt;\"), 1.5, min = 0.1, max = 5)),\n           div(style=\"height: 80px;\",sliderInput('alpha12', HTML(\"&alpha;&lt;sub&gt;12&lt;/sub&gt;\"), 0.8, min = 0.1, max = 5))\n    ),\n    column(4,\n           div(style=\"height: 80px;\",sliderInput('alpha21', HTML(\"&alpha;&lt;sub&gt;21&lt;/sub&gt;\"), 0.9, min = 0.1, max = 5)),\n           div(style=\"height: 80px;\",sliderInput('alpha22', HTML(\"&alpha;&lt;sub&gt;22&lt;/sub&gt;\"), 1.1, min = 0.1, max = 5))\n    )\n  )\n  \n  \n)\n\nserver &lt;- function(input, output, session) {\n  N1 &lt;- seq(0, 20, 0.01)\n  N2_1 &lt;-reactive({\n    (input$r1 - input$alpha11 * N1) / input$alpha12 \n  })\n  \n  N2_2 &lt;- reactive({\n    (input$r2 - input$alpha21 * N1) / input$alpha22\n  })\n\n  \n  # sim lv model\n  sim_result &lt;- reactive({\n    Sim_lotka_volterra(100, input$alpha11, input$alpha12, input$alpha21, input$alpha22, input$r1, input$r2, 0.1, 0.1)\n  })\n  \n  output$text &lt;- renderText({\n    if(input$r1 / input$alpha11 &gt; input$r2 / input$alpha21 & input$r1 / input$alpha12 &gt;  input$r2 / input$alpha22){HTML(\"Case 1: Species 1 wins\")}\n    else if(input$r1 / input$alpha11 &lt; input$r2 / input$alpha21 & input$r1 / input$alpha12 &lt;  input$r2 / input$alpha22){\"Case 2: Species 2 wins\"}\n    else if(input$r1 / input$alpha11 &lt; input$r2 / input$alpha21 & input$r1 / input$alpha12 &gt;  input$r2 / input$alpha22){\"Case 3: Coexistence\"}\n    else if(input$r1 / input$alpha11 &gt; input$r2 / input$alpha21 & input$r1 / input$alpha12 &lt;  input$r2 / input$alpha22){\"Case 4: Founder control\"}\n    else {\"Case 5: Neutrality\"}\n    \n  })\n  \n  output$plot &lt;- renderPlotly({\n    Ns &lt;- data.frame(N1 = N1, N2_1 = N2_1(), N2_2 = N2_2())\n    pos_Ns &lt;- Ns[Ns$N2_1 &gt;= 0 | Ns$N2_2 &gt;= 0,]\n    x_lim &lt;- c(0, max(pos_Ns$N1) + 1)\n    y_lim &lt;- c(0, max(pos_Ns$N2_1, pos_Ns$N2_2)+1)\n    p &lt;- plot_ly(x = N1, y = N2_1(), type = 'scatter', mode = 'lines', name = 'dN1/dt = 0') %&gt;%\n      add_trace(x = N1, y = N2_2(), type = 'scatter', mode = 'lines', name = 'dN2/dt = 0') %&gt;%\n      add_trace(x = -1, y = -1, type = 'scatter', mode = 'markers', name = 'Stable equilibrium point',\n                marker = list(color = 'rgb(0, 0, 0)', size = 10, line = list(color = 'rgb(0, 0, 0)',\n                                                                             width = 1\n                ))) %&gt;%\n      add_trace(x = -2, y = -1, type = 'scatter', mode = 'markers', name = 'Unstable equilibrium point',\n                marker = list(color = 'rgb(255, 255, 255)', size = 10, line = list(color = 'rgb(0, 0, 0)',\n                                                                             width = 1\n                ))) %&gt;%\n      add_trace(x = sim_result()$N1, y = sim_result()$N2, type = 'scatter', mode = 'lines+markers', name = 'Trajectory', \n                marker = list(color = 'grey'), line = list(color = 'grey')) %&gt;%\n      add_trace(x = 0.1, y=0.1, type = 'scatter', mode = 'markers', name = 'Initial condition',\n                marker = list(color = 'rgb(0, 0, 0)', size = 5, line = list(color = 'rgb(0, 0, 0)',\n                                                                             width = 1\n                )))\n    \n    if(input$r1 / input$alpha11 &gt; input$r2 / input$alpha21 & input$r1 / input$alpha12 &gt;  input$r2 / input$alpha22){\n      p &lt;- p %&gt;%\n        add_trace(x = input$r1 / input$alpha11, y = 0, type = 'scatter', mode = 'markers', name = 'Stable equilibrium point',\n                  marker = list(color = 'rgb(0, 0, 0)', size = 10, line = list(color = 'rgb(0, 0, 0)',\n                                                                               width = 1\n                  )), showlegend = FALSE) %&gt;%\n        add_trace(x = 0, y = input$r2 / input$alpha22, type = 'scatter', mode = 'markers', name = 'Unstable equilibrium point',\n                  marker = list(color = 'rgb(255, 255, 255)', size = 10, line = list(color = 'rgb(0, 0, 0)',\n                                                                               width = 1\n                  )), showlegend = FALSE) %&gt;%\n        add_trace(x = 0, y = 0, type = 'scatter', mode = 'markers', name = 'Unstable equilibrium point',\n                  marker = list(color = 'rgb(255, 255, 255)', size = 10, line = list(color = 'rgb(0, 0, 0)',\n                                                                                     width = 1\n                  )), showlegend = FALSE) %&gt;%\n        layout(xaxis = list(title = 'N1', range = x_lim), yaxis = list(title = 'N2', range = y_lim))\n    } else if(input$r1 / input$alpha11 &lt; input$r2 / input$alpha21 & input$r1 / input$alpha12 &lt;  input$r2 / input$alpha22){\n\n        p &lt;- p %&gt;%\n          add_trace(x = input$r1 / input$alpha11, y = 0, type = 'scatter', mode = 'markers', name = '',\n                  marker = list(color = 'rgb(255, 255, 255)', size = 10, line = list(color = 'rgb(0, 0, 0)',\n                                                                               width = 1\n                  )), showlegend = FALSE) %&gt;%\n        add_trace(x = 0, y = input$r2 / input$alpha22, type = 'scatter', mode = 'markers', name = '',\n                  marker = list(color = 'rgb(0, 0, 0)', size = 10, line = list(color = 'rgb(0, 0, 0)',\n                                                                               width = 1\n                  )), showlegend = FALSE) %&gt;%\n        add_trace(x = 0, y = 0, type = 'scatter', mode = 'markers', name = '',\n                  marker = list(color = 'rgb(255, 255, 255)', size = 10, line = list(color = 'rgb(0, 0, 0)',\n                                                                                     width = 1\n                  )), showlegend = FALSE) %&gt;%\n        layout(xaxis = list(title = 'N1', range = x_lim), yaxis = list(title = 'N2', range = y_lim))\n    } else if(input$r1 / input$alpha11 &lt; input$r2 / input$alpha21 & input$r1 / input$alpha12 &gt;  input$r2 / input$alpha22){\n      sol &lt;- reactive({solve(matrix(c(input$alpha11, input$alpha21, input$alpha12, input$alpha22), 2, 2), c(input$r1, input$r2))})\n      \n      p &lt;- p %&gt;%\n        add_trace(x = sol()[1], y = sol()[2], type = 'scatter', mode = 'markers', name = '',\n                       marker = list(color = 'rgb(0, 0, 0)', size = 10, line = list(color = 'rgb(0, 0, 0)',\n                                                                                    width = 1\n                       )), showlegend = FALSE) %&gt;%\n        add_trace(x = input$r1 / input$alpha11, y = 0, type = 'scatter', mode = 'markers', name = '',\n                  marker = list(color = 'rgb(255, 255, 255)', size = 10, line = list(color = 'rgb(0, 0, 0)',\n                                                                                     width = 1\n                  )), showlegend = FALSE) %&gt;%\n        add_trace(x = 0, y = input$r2 / input$alpha22, type = 'scatter', mode = 'markers', name = '',\n                  marker = list(color = 'rgb(255, 255, 255)', size = 10, line = list(color = 'rgb(0, 0, 0)',\n                                                                               width = 1\n                  )), showlegend = FALSE) %&gt;%\n        add_trace(x = 0, y = 0, type = 'scatter', mode = 'markers', name = '',\n                  marker = list(color = 'rgb(255, 255, 255)', size = 10, line = list(color = 'rgb(0, 0, 0)',\n                                                                                     width = 1\n                  )), showlegend = FALSE) %&gt;%\n        layout(xaxis = list(title = 'N1', range = x_lim), yaxis = list(title = 'N2', range = y_lim))\n      \n    } else if(input$r1 / input$alpha11 &gt; input$r2 / input$alpha21 & input$r1 / input$alpha12 &lt;  input$r2 / input$alpha22){\n      sol &lt;- reactive({solve(matrix(c(input$alpha11, input$alpha21, input$alpha12, input$alpha22), 2, 2), c(input$r1, input$r2))})\n      \n      p &lt;- p %&gt;%\n        add_trace(x = sol()[1], y = sol()[2], type = 'scatter', mode = 'markers', name = '',\n                  marker = list(color = 'rgb(255, 255, 255)', size = 10, line = list(color = 'rgb(0, 0, 0)',\n                                                                               width = 1\n                  )), showlegend = FALSE) %&gt;%\n        add_trace(x = input$r1 / input$alpha11, y = 0, type = 'scatter', mode = 'markers', name = '',\n                  marker = list(color = 'rgb(0, 0, 0)', size = 10, line = list(color = 'rgb(0, 0, 0)',\n                                                                               width = 1\n                  )), showlegend = FALSE) %&gt;%\n        add_trace(x = 0, y = input$r2 / input$alpha22, type = 'scatter', mode = 'markers', name = '',\n                  marker = list(color = 'rgb(0, 0, 0)', size = 10, line = list(color = 'rgb(0, 0, 0)',\n                                                                                     width = 1\n                  )), showlegend = FALSE) %&gt;%\n        add_trace(x = 0, y = 0, type = 'scatter', mode = 'markers', name = '',\n                  marker = list(color = 'rgb(255, 255, 255)', size = 10, line = list(color = 'rgb(0, 0, 0)',\n                                                                                     width = 1\n                  )), showlegend = FALSE) %&gt;%\n        layout(xaxis = list(title = 'N1', range = x_lim), yaxis = list(title = 'N2', range = y_lim))\n    } else {\n      p &lt;- p %&gt;%\n        layout(xaxis = list(title = 'N1', range = x_lim), yaxis = list(title = 'N2', range = y_lim))\n    }\n    \n    p\n  })\n  \n}\n# Create Shiny app ----\nshinyApp(ui = ui, server = server)\n\n\nThe stability of the equilibrium points\nConsider a small perturbation from an equilibrium.\nCalculate eigenvalues \\(\\lambda\\) of Jacobian matrix \\(J\\) evaluated at an equilibrium \\((N_1^*, N_2^*)\\):\n\\[\nJ = \\left.\\begin{pmatrix}\n\\frac{\\partial f_1}{\\partial N_1} & \\frac{\\partial f_1}{\\partial N_2} \\\\\n\\frac{\\partial f_2}{\\partial N_1} & \\frac{\\partial f_2}{\\partial N_2}\n\\end{pmatrix}\\right|_{(N_1^*, N_2^*)}\n\\]\nwhere \\(f_1 =  \\left(r_1 - \\alpha_{11} N_1 - \\alpha_{12} N_2\\right) N_1\\) and \\(f_2 = \\left(r_2 - \\alpha_{21} N_1 - \\alpha_{22} N_2\\right) N_2\\). The eigenvalues of the Jacobian matrix determine the stability of the equilibrium points.\n\nStable equilibrium\nIf the eighenvalues have negative real parts, the equilibrium point is stable.\nUnstable equilibrium\nIf any eighenvalue has positive real parts, the equilibrium point is unstable.\nStability analysis failure\nIf largest eigenvalue is 0, linear stability analysis fails (possibly neutral).\n\n\n\nInvasion analysis\nThe invasion analysis is used to determine the outcome of the competition between two species.\nIf any species can invade a community when the other species is at equilibrium, the two species can stably coexist.\nThe invasion rate of Species \\(i\\) is defined as the per capita growth rate when rare while Species \\(j\\) is at equilibrium:\n\\[\n\\lambda_{ij} = \\left.\\frac{1}{N_i} \\frac{dN_i}{dt}\\right|_{N_j^*,N_i=0}\n\\]\nSpecies \\(j\\) reaches equilibrium at \\(N_j^*=r_j / \\alpha_{jj}\\) on its own. So, the invasion rate of Species \\(i\\) yields:\n\\[\n\\lambda_{ij} = r_i - \\frac{\\alpha_{ij}}{\\alpha_{jj}} r_j\n\\]\nSo, the rule is to examine the sign of \\(\\lambda_{ij}\\) and \\(\\lambda_{ji}\\).\n\nCase 1: Species 1 wins\nIf \\(\\lambda_{12} &gt; 0\\) and \\(\\lambda_{21} &lt; 0\\), species 1 outcompetes species 2.\nCase 2: Species 2 wins\nIf \\(\\lambda_{12} &lt; 0\\) and \\(\\lambda_{21} &gt; 0\\), species 2 outcompetes species 1.\nCase 3: Coexistence\nIf \\(\\lambda_{12} &gt; 0\\) and \\(\\lambda_{21} &gt; 0\\), the two species can stably coexist (“mutual invasibility”).\nCase 4: Founder control\nIf \\(\\lambda_{12} &lt; 0\\) and \\(\\lambda_{21} &lt; 0\\), it is founder control.\n\n\n\nModern coexistence theory\nPeter Chesson (e.g. 2000, 2020) developed the modern coexistence theory based on the Lotka-Volterra competition model. Two key concepts, niche differences and fitness differences, are derived from the invasion criterion.\nBased on the invasion criterion, stable coexistence is achieved if and only if the two species are “mutually invasible”:\n\\[\n\\lambda_{12} &gt; 0 \\text{ and } \\lambda_{21} &gt; 0\n\\]\nwhich are:\n\\[\nr_1 - \\frac{\\alpha_{12}}{\\alpha_{22}} r_2 &gt; 0 \\text{ and } r_2 - \\frac{\\alpha_{21}}{\\alpha_{11}} r_1 &gt; 0.\n\\]\nSo,\n\\[\n\\frac{\\alpha_{12}}{\\alpha_{22}} &lt; \\frac{r_1}{r_2} &lt; \\frac{\\alpha_{11}}{\\alpha_{21}}.\n\\]\nAfter symmetrizing the inequality, we have\n\\[\n\\sqrt\\frac{\\alpha_{12}\\alpha_{21}}{\\alpha_{11}\\alpha_{22}} &lt; \\sqrt\\frac{\\alpha_{12}\\alpha_{22}}{\\alpha_{11}\\alpha_{21}} \\frac{r_1}{r_2} &lt; \\sqrt\\frac{\\alpha_{11}\\alpha_{22}}{\\alpha_{12}\\alpha_{21}} .\n\\]\nwhich can be simplified as\n\\[\n\\frac{1}{\\rho} &lt; \\delta &lt; \\rho\n\\]\nwhere \\(\\rho = \\sqrt\\frac{\\alpha_{11}\\alpha_{22}}{\\alpha_{12}\\alpha_{21}}\\) and \\(\\delta = \\sqrt\\frac{\\alpha_{12}\\alpha_{22}}{\\alpha_{11}\\alpha_{21}} \\frac{r_1}{r_2}\\).\n\\(\\rho\\) is then interpreted as the “niche overlap” and \\(\\delta\\) as the “fitness difference”.\nThis crieteria then seperates the space of the niche overlap and fitness difference into four regions:\n\n\n\nniche overlap and fitness difference\n\n\n\n\nLotka-Volterra competition model: Pros & Cons\n\nPros\n\nAnalytically tractable: The model is simple and can be solved analytically;\nGraphical approach: Easy to do the graphical analysis based on the zero-net-growth isoclines;\nSimple and clear outcomes of competition. For example, 5 outcomes of competition can be derived from two-species cases;\nPhenomenological: The model can be used to describe the competition between two species in a simple way.\n\nCons\n\nLinear competitive effects: higher order interactions are ignored;\nNo physical meaning to parameters: The parameters in the model have no physical meaning;\nHow does competitive outcome depend on environmental gradients? The analysis relies on constant parameters. Thus, the model is not suitable for studying the competition along environmental gradients;\nCurse of dimensionality: The model and the analysis are not suitable for studying the competition among more than two species.\nHow are parameters related / constrained? The model does not provide any information on how the parameters are related or constrained.\n\n\n\n\nReferences\nBarabás G, D’Andrea R, Stump SM (2018) Chesson’s coexistence theory. Ecological Monographs 88: 277– 303.\nChesson P (2000) Mechanisms of maintenance of species diversity. Annual Review of Ecology, Evolution, and Systematics 31: 343–366\nChesson P (2020) Species coexistence. In: Theoretical Ecology. Oxford University Press, pp 5–27 Gause GF, Witt AA (1935) Behavior of mixed populations and the problem of natural selection. American Naturalist 69: 596–609\nGrainger TN, Levine JM, Gilbert B (2019) The invasion criterion: a common currency for ecological research. Trends in Ecology & Evolution 34: 925–935.\nKingsland S (1995) Modeling Nature: Episodes in the History of Population Ecology. 2nd edition.\nMallet J (2012) The struggle for existence: how the notion of carrying capacity, K, obscures the links between demography, Darwinian evolution, and speciation. Evolutionary Ecology Research 14: 627–655\nMetz JAJ, Nisbet RM, Geritz SAH (1992) How should we define “fitness” for general ecological scenarios. Trends in Ecology & Evolution 7: 198–202"
  }
]