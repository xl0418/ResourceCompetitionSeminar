[
  {
    "objectID": "posts/06-2024/RCSeminar2014-06.html",
    "href": "posts/06-2024/RCSeminar2014-06.html",
    "title": "06 – Variable environment and the storage (Droop) model",
    "section": "",
    "text": "In this session, we discussed how variable environment is considered in the resource competition theory and what the storage model (Droop model) is.\n\nMaterials\nThe video record of the seminar can be found HERE.\nThe slides can be found HERE.\nThe Mathematica notebook is HERE.\n\n\nVariables environment\nThe population growth in a constant environment is often defined as an exponential growth:\n\\[\n\\frac{dN}{dt} = rN\n\\]\nIt can be solved as:\n\\[\nN(t) = N_0 e^{rt}\n\\]\nor in a logarithmic form:\n\\[\n\\log(N(t)) = \\log(N_0) + rt\n\\]\nFor population growth in a variable environment, the growth rate \\(r\\) is not constant. It can be a function of time. For example, the growth rate can be a step function of time:\n\\[\nr(t) = \\begin{cases}\n2, & \\text{if } t &lt; 1 \\\\\n-1, & \\text{if } 1 \\leq t &lt; 2 \\\\\n3, & \\text{if } t \\geq 2\n\\end{cases}\n\\]\nThe density can be solved by integrating the growth rate:\n\\[\n\\log(N(t)) = \\log(N_0) + \\int_0^t r(t) dt\\\\\n= \\log(N_0) +  \\bar{r} t\n\\]\nThe growth curves in a constant and variable environment are shown in the following figure.\n#| standalone: true\n#| viewerHeight: 600\n#| viewerWidth: 800\nlibrary(shiny)\nlibrary(bslib)\nlibrary(plotly)\nlibrary(Matrix)\n\n\nNt &lt;- function(N0, r, t){\n  N0 * exp(r * t)\n}\n\nNt_variable &lt;- function(N0, t1, t2, t3){\n  nt_temp &lt;- c()\n  for (i in 1:length(t1)){\n    nt_temp &lt;- c(nt_temp, N0 * exp(2 * t[i]))\n  }\n  nt10 &lt;- nt_temp[length(nt_temp)]\n  for (i in 1:length(t2)){\n    nt_temp &lt;- c(nt_temp, nt10 * exp( -1 * t[i]))\n  }\n  nt20 &lt;- nt_temp[length(nt_temp)]\n  for (i in 1:length(t3)){\n    nt_temp &lt;- c(nt_temp, nt20 * exp( 3 * t[i]))\n  }\n  return(nt_temp)\n}\n\n\n# Define UI for app that draws a histogram ----\n# Define UI for app that draws a histogram ----\nui &lt;- fluidPage(\n  fluidRow(\n    \n    tabsetPanel(id = \"tabset\",\n                tabPanel(\"Population growth in constant environment\", \n                         column(4, \n                                div(style=\"height: 80px;\",sliderInput('n0_tab1', HTML(\"N&lt;sub&gt;0&lt;/sub&gt;\"), 0.1, min = 0.01, max = 2))\n                         ),\n                         column(4,\n                                div(style=\"height: 80px;\",sliderInput('r', HTML(\"r\"), 1.1, min = 0.1, max = 10))\n                         )\n                ),\n                tabPanel(\"Population growth in variable environment\",\n                         column(4, \n                                div(style=\"height: 80px;\",sliderInput('n0_tab2', HTML(\"N&lt;sub&gt;0&lt;/sub&gt;\"), 0.1, min = 0.01, max = 2))\n                         )\n                )\n    )),\n  \n  \n  \n  fluidRow(\n    column(12, \n           plotlyOutput(\"plot1\", width=700, height=300),\n           plotlyOutput(\"plot_r\", width=700, height=300)\n    ))\n  \n  \n)\n\nserver &lt;- function(input, output, session) {\n  output$plot_r &lt;- renderPlotly({\n    if (input$tabset == \"Population growth in constant environment\") {\n      # plot r in time\n      t &lt;- seq(0, 3, 0.1)\n      r &lt;- input$r\n      p &lt;- plot_ly(x = t, y = r, type = 'scatter', mode = 'lines', name = 'r', line = list(color = 'orange', width = 4))\n      p\n    } else {\n      # r is a step function\n      t &lt;- seq(0, 3, 0.1)\n      r &lt;- c()\n      for (i in 1:length(t)){\n        if (t[i] &lt; 1){\n          r[i] &lt;- 2\n        } else if (t[i] &lt; 2 & t[i] &gt;= 1){\n          r[i] &lt;- -1\n        } else {\n          r[i] &lt;- 3\n        }\n      }\n      p &lt;- plot_ly(x = t, y = r, type = 'scatter', mode = 'lines', name = 'r', line = list(color = 'orange', width = 4))\n      p\n    }\n    # xlabel \n    p &lt;- p %&gt;% layout(xaxis = list(title = \"Time\"), yaxis = list(title = \"r\"))\n    p\n    \n  })\n  \n  \n  output$plot1 &lt;- renderPlotly({\n    if (input$tabset == \"Population growth in constant environment\") {\n      t &lt;- seq(0, 3, 0.1)\n      \n      nt &lt;-reactive({\n        Nt(input$n0_tab1, input$r, t)\n      })\n      \n      gr &lt;- data.frame(nt = nt(), t = t)\n      # browser()\n      p &lt;- plot_ly(data = gr) %&gt;%\n        add_trace(x = ~t, y = ~nt, type = 'scatter', mode = 'lines+markers', name = 'Density')\n      \n      p\n    } else {\n\n      nt &lt;- reactive({\n        t1 &lt;- seq(0, 1, 0.1)\n        t2 &lt;- seq(0, 1, 0.1)\n        t3 &lt;- seq(0, 1, 0.1)\n        Nt_variable(input$n0_tab2, t1, t2, t3)\n      })\n      # browser()\n      gr &lt;- data.frame(nt = nt(), t = c(t1, 1+t2, 2+t3))\n      # browser()\n      p &lt;- plot_ly(data = gr) %&gt;%\n        add_trace(x =~t, y = ~nt, type = 'scatter', mode = 'lines+markers', name = 'Density')\n      p\n    }\n    p &lt;- p %&gt;% layout(xaxis = list(title = \"Time\"), yaxis = list(title = \"Density\"))\n    p\n    \n  }\n  )\n  \n}\n# Create Shiny app ----\nshinyApp(ui = ui, server = server)\n\nSo, \\(\\bar{r}\\) is the appropriate definition of growth / fitness in variable environments for unstructured populations. This is true for any kinds of environmental variation (periodic, random). It is also useful for invasion analysis (coexistence criteria).\nHowever, things become more complicated for structured populations.\nTwo types of structure:\nExtensive structure: Floquet exponents (Klausmeier 2008 Theoretical Ecology), Lyapunov exponents (Metz et al. 1992 TREE)\nIntensive structure: let intensive variable reach attractor, then calculate growth (Litchman et al. 2009 PNAS)\n\n\nStorage model (Droop model)\nUnder construction!\n\n\n\nIllustration of Droop model\n\n\n\n\nReferences"
  },
  {
    "objectID": "posts/04-2024/RCSeminar2014-04.html",
    "href": "posts/04-2024/RCSeminar2014-04.html",
    "title": "04 – The resource-consumer competition model",
    "section": "",
    "text": "In this session, we discussed about the resource-consumer model."
  },
  {
    "objectID": "posts/04-2024/RCSeminar2014-04.html#the-simulation",
    "href": "posts/04-2024/RCSeminar2014-04.html#the-simulation",
    "title": "04 – The resource-consumer competition model",
    "section": "The simulation",
    "text": "The simulation\nTry on this interactive plot and see which species would win.\n#| standalone: true\n#| viewerHeight: 800\n#| viewerWidth: 900\nlibrary(shiny)\nlibrary(bslib)\nlibrary(plotly)\nlibrary(Matrix)\n\ngrowth_rate &lt;- function(mu_max,k, R){\n  return(mu_max * R / (R + k))\n}\n\n\nSim_rc &lt;- function(tt, mu11, mu12, mu21, mu22,\n                   k11,k12,k21,k22,\n                   v11, v12, v21, v22,\n                   r1in, r2in,\n                   N10, N20, R10, R20,\n                   m,\n                   mode) {\n  N1 &lt;- c(N10)\n  N2 &lt;- c(N20)\n  R1 &lt;- c(R10)\n  R2 &lt;- c(R20)\n  for(ti in 1:tt){\n    temp_N1 &lt;- N1[ti]\n    temp_N2 &lt;- N2[ti]\n    temp_R1 &lt;- R1[ti]\n    temp_R2 &lt;- R2[ti]\n    for(tii in 1:100){\n      if(mode == \"ess\"){\n        mu1 &lt;- min(growth_rate(mu11, k11, temp_R1), growth_rate(mu12, k12, temp_R2))\n        mu2 &lt;- min(growth_rate(mu21, k21, temp_R1), growth_rate(mu22, k22, temp_R2))\n        c11 &lt;- min(growth_rate(v11, k11, temp_R1), growth_rate(v12, k12, temp_R2))\n        c12 &lt;- min(growth_rate(v11, k11, temp_R1), growth_rate(v12, k12, temp_R2))\n        c21 &lt;- min(growth_rate(v21, k21, temp_R1), growth_rate(v22, k22, temp_R2))\n        c22 &lt;- min(growth_rate(v21, k21, temp_R1), growth_rate(v22, k22, temp_R2))\n        \n      } else {\n        mu1 &lt;- growth_rate(mu11, k11, temp_R1) + growth_rate(mu12, k12, temp_R2)\n        mu2 &lt;- growth_rate(mu21, k21, temp_R1) + growth_rate(mu22, k22, temp_R2)\n        c11 &lt;- v11 * temp_R1\n        c12 &lt;- v12 * temp_R2\n        c21 &lt;- v21 * temp_R1\n        c22 &lt;- v22 * temp_R2\n      }\n      \n      dN1 &lt;- (mu1 - m) * temp_N1 / 100\n      dN2 &lt;- (mu2 - m) * temp_N2 / 100\n      dR1 &lt;- ((r1in - temp_R1) - c11 * temp_N1 - c21 * temp_N2) / 100\n      dR2 &lt;- ((r2in - temp_R2) - c12 * temp_N1 - c22 * temp_N2) / 100\n      \n      temp_N1 &lt;- max(temp_N1 + dN1, 0)\n      temp_N2 &lt;- max(temp_N2 + dN2, 0)\n      temp_R1 &lt;- max(temp_R1 + dR1, 0)\n      temp_R2 &lt;- max(temp_R2 + dR2, 0)\n      \n    }\n    \n    N1 &lt;- c(N1, temp_N1)\n    N2 &lt;- c(N2, temp_N2)\n    \n    R1 &lt;- c(R1, temp_R1)\n    R2 &lt;- c(R2, temp_R2)\n  }\n  return(data.frame(N1 = N1, N2 = N2, R1 = R1, R2 = R2, cc = 1:(tt+1)))\n  \n}\n\n\n# Define UI for app that draws a histogram ----\n# Define UI for app that draws a histogram ----\nui &lt;- fluidPage(\n  headerPanel(''),\n  \n  fluidRow(\n    column(12, \n           textOutput(\"text\"),\n           tags$head(tags$style(\"#text{color: black;\n                                 font-size: 30px;\n                                 font-style: italic;\n                                 }\"\n           )\n           ),\n           plotlyOutput(\"plot1\", width=700, height=250),\n           plotlyOutput(\"plot2\", width=700, height=250)\n    )\n  ), \n  \n  fluidRow(\n    column(4, \n           div(style=\"height: 80px;\",sliderInput('mu1max', HTML(\"&mu;&lt;sub&gt;1,max&lt;/sub&gt;\"), 1.4, min = 0.1, max = 2)),\n           div(style=\"height: 80px;\",sliderInput('mu2max', HTML(\"&mu;&lt;sub&gt;2,max&lt;/sub&gt;\"), 1.1, min = 0.1, max = 2))\n    ),\n    column(4,\n           div(style=\"height: 80px;\", sliderInput('k1', HTML(\"K&lt;sub&gt;1&lt;/sub&gt;\"), 2.5, min = 0.1, max = 3)),\n           div(style=\"height: 80px;\",sliderInput('k2', HTML(\"K&lt;sub&gt;2&lt;/sub&gt;\"), 0.4, min = 0.1, max = 3))\n    ),\n    column(4,\n           div(style=\"height: 80px;\", sliderInput('m', \"m\", 0.4, min = 0.01, max = 1)),\n    )\n  )\n  \n  \n)\n\nserver &lt;- function(input, output, session) {\n  output$text &lt;- renderText({\n    \"Michaelis-Menten-Monod growth\"\n  })\n  \n  \n  \n  \n  # sim lv model\n  sim_result &lt;- reactive({\n    Sim_rc(100, input$mu1max, 0, input$mu2max, 0,\n           input$k1,0, input$k2, 0,\n           3 * input$mu1max,  0, 3 * input$mu2max,0,\n           10, 10, 0.1, 0.1, 1, 1, input$m,\n           \"sub\")\n  })\n  # browser()\n  \n  output$plot1 &lt;- renderPlotly({\n      R &lt;- seq(0, 10, 0.01)\n      \n      mu1 &lt;-reactive({\n        growth_rate(input$mu1max, input$k1, R)\n      })\n      \n      \n      mu2 &lt;-reactive({\n        growth_rate(input$mu2max, input$k2, R)\n      })\n      \n      gr &lt;- data.frame(re = R, mu1 = mu1(), mu2 = mu2())\n      # browser()\n      p &lt;- plot_ly(data = gr) %&gt;%\n        add_trace(x = ~re, y = ~mu1, type = 'scatter', mode = 'lines', name = 'Species 1') %&gt;%\n        add_trace(x = ~re, y = ~mu2, type = 'scatter', mode = 'lines', name = 'Species 2')\n        \n      p &lt;- p %&gt;%\n        add_segments(y=input$m, yend = input$m, x = 0, xend=10, type = 'scatter', mode = 'lines', name = \"m\")\n   \n      # xlim\n      # p &lt;- p %&gt;% layout(xaxis = list(range = c(0, 2)),\n      #                   yaxis = list(range = c(0, 2)))\n      \n      \n      \n      \n      p\n  })\n  \n  output$plot2 &lt;- renderPlotly({\n    \n    # browser()\n    p &lt;- plot_ly(data = sim_result()) %&gt;%\n      add_trace(x = ~cc, y = ~N1, type = 'scatter', mode = 'lines', name = 'Species 1') %&gt;%\n      add_trace(x = ~cc, y = ~N2, type = 'scatter', mode = 'lines', name = 'Species 2')\n    \n\n    # xlim\n    # p &lt;- p %&gt;% layout(xaxis = list(range = c(0, 2)),\n    #                   yaxis = list(range = c(0, 2)))\n    \n    \n    \n    \n    p\n  })\n\n}\n# Create Shiny app ----\nshinyApp(ui = ui, server = server)"
  },
  {
    "objectID": "posts/04-2024/RCSeminar2014-04.html#the-essential-resource-model",
    "href": "posts/04-2024/RCSeminar2014-04.html#the-essential-resource-model",
    "title": "04 – The resource-consumer competition model",
    "section": "The essential resource model",
    "text": "The essential resource model\nThe two-species-two-essential-resource model is given by\n\\[\n\\begin{aligned}\n\\frac{dN_1}{dt} &=  \\left( \\min(\\mu_{11}R_1, \\mu_{12}R_2) - m \\right) N_1\\\\\n\\frac{dN_2}{dt} &=  \\left( \\min(\\mu_{21}R_1, \\mu_{22}R_2) - m \\right) N_2\\\\\n\\frac{dR_1}{dt} &=  a \\left(R_{1,in}-R_1 \\right) - \\min(V_{11}R_1, V_{12}R_2) N_1 - \\min(V_{21}R_1, V_{22}R_2) N_2 \\\\\n\\frac{dR_2}{dt} &=  a \\left(R_{2,in}-R_2 \\right) - \\min(V_{11}R_1, V_{12}R_2) N_1 - \\min(V_{21}R_1, V_{22}R_2) N_2 \\\\\n\\end{aligned}\n\\]"
  },
  {
    "objectID": "posts/04-2024/RCSeminar2014-04.html#the-substitutable-resource-model",
    "href": "posts/04-2024/RCSeminar2014-04.html#the-substitutable-resource-model",
    "title": "04 – The resource-consumer competition model",
    "section": "The substitutable resource model",
    "text": "The substitutable resource model\nThe two-species-two-substitutable-resource model is given by\n\\[\n\\begin{aligned}\n\\frac{dN_1}{dt} &=  \\left( \\mu_{11}R_1 + \\mu_{12}R_2 - m \\right) N_1\\\\\n\\frac{dN_2}{dt} &=  \\left( \\mu_{21}R_1 + \\mu_{22}R_2 - m \\right) N_2\\\\\n\\frac{dR_1}{dt} &=  a \\left(R_{1,in}-R_1 \\right) - V_{11}R_1 N_1 - V_{21}R_1 N_2 \\\\\n\\frac{dR_2}{dt} &=  a \\left(R_{2,in}-R_2 \\right) - V_{12}R_2 N_1 - V_{22}R_2 N_2 \\\\\n\\end{aligned}\n\\]"
  },
  {
    "objectID": "posts/04-2024/RCSeminar2014-04.html#the-zngi-analysis",
    "href": "posts/04-2024/RCSeminar2014-04.html#the-zngi-analysis",
    "title": "04 – The resource-consumer competition model",
    "section": "The ZNGI analysis",
    "text": "The ZNGI analysis\nWe take the essential resource competition model as an example. The ZNGIs of the two species are given by\n\\[\n\\begin{aligned}\n\\min(\\mu_{11}R_1, \\mu_{12}R_2) - m  &= 0\\\\\n\\min(\\mu_{21}R_1, \\mu_{22}R_2) - m  &= 0\n\\end{aligned}\n\\]\nwhich gives the two “L” shaped ZNGIs in the plot.\nIf the two ZNGIs cross, the crossing point is a potential coexistence destination. Whether it is a stable equilibrium relies on the impact vectors and the resource supply rates. See Lecture 2 for details.\n#| standalone: true\n#| viewerHeight: 800\n#| viewerWidth: 1000\n\n\n\nSim_rc_ess &lt;- function(tt, mu11, mu12, mu21, mu22,\n                       q11, q12, q21, q22,\n                       r1in, r2in,\n                       N10, N20, R10, R20,\n                       m) {\n  N1 &lt;- c(N10)\n  N2 &lt;- c(N20)\n  R1 &lt;- c(R10)\n  R2 &lt;- c(R20)\n  for(ti in 1:tt){\n    temp_N1 &lt;- N1[ti]\n    temp_N2 &lt;- N2[ti]\n    temp_R1 &lt;- R1[ti]\n    temp_R2 &lt;- R2[ti]\n    for(tii in 1:100){\n      \n      mu1 &lt;- min(mu11 * temp_R1, mu12 * temp_R2)\n      mu2 &lt;- min(mu21 * temp_R1, mu22 * temp_R2)\n      \n      \n      dN1 &lt;- (mu1  - m) * temp_N1 / 100\n      dN2 &lt;- (mu2  - m) * temp_N2 / 100\n      dR1 &lt;- ((r1in - temp_R1) - q11 * mu1 * temp_N1 - q21 * mu2 * temp_N2) / 100\n      dR2 &lt;- ((r2in - temp_R2) - q12 * mu1 * temp_N1 - q22 * mu2 * temp_N2) / 100\n      \n      temp_N1 &lt;- max(temp_N1 + dN1, 0)\n      temp_N2 &lt;- max(temp_N2 + dN2, 0)\n      temp_R1 &lt;- max(temp_R1 + dR1, 0)\n      temp_R2 &lt;- max(temp_R2 + dR2, 0)\n      \n    }\n    \n    N1 &lt;- c(N1, temp_N1)\n    N2 &lt;- c(N2, temp_N2)\n    \n    R1 &lt;- c(R1, temp_R1)\n    R2 &lt;- c(R2, temp_R2)\n  }\n  return(data.frame(N1 = N1, N2 = N2, R1 = R1, R2 = R2, cc = 1:(tt+1)))\n  \n}\n\n\nSim_rc_sub &lt;- function(tt, mu11, mu12, mu21, mu22,\n                       v11, v12, v21, v22,\n                       r1in, r2in,\n                       N10, N20, R10, R20,\n                       m) {\n  N1 &lt;- c(N10)\n  N2 &lt;- c(N20)\n  R1 &lt;- c(R10)\n  R2 &lt;- c(R20)\n  for(ti in 1:tt){\n    temp_N1 &lt;- N1[ti]\n    temp_N2 &lt;- N2[ti]\n    temp_R1 &lt;- R1[ti]\n    temp_R2 &lt;- R2[ti]\n    for(tii in 1:100){\n      \n      mu1 &lt;- mu11 * temp_R1 + mu12 * temp_R2\n      mu2 &lt;- mu21 * temp_R1 + mu22 * temp_R2\n      \n      \n      dN1 &lt;- (mu1  - m) * temp_N1 / 100\n      dN2 &lt;- (mu2  - m) * temp_N2 / 100\n      dR1 &lt;- ((r1in - temp_R1) - v11 * temp_R1 * temp_N1 - v21 * temp_R1 * temp_N2) / 100\n      dR2 &lt;- ((r2in - temp_R2) - v12 * temp_R2 * temp_N1 - v22 * temp_R2 * temp_N2) / 100\n      \n      temp_N1 &lt;- max(temp_N1 + dN1, 0)\n      temp_N2 &lt;- max(temp_N2 + dN2, 0)\n      temp_R1 &lt;- max(temp_R1 + dR1, 0)\n      temp_R2 &lt;- max(temp_R2 + dR2, 0)\n      \n    }\n    \n    N1 &lt;- c(N1, temp_N1)\n    N2 &lt;- c(N2, temp_N2)\n    \n    R1 &lt;- c(R1, temp_R1)\n    R2 &lt;- c(R2, temp_R2)\n  }\n  return(data.frame(N1 = N1, N2 = N2, R1 = R1, R2 = R2, cc = 1:(tt+1)))\n  \n}\n\n\n# Define UI for app that draws a histogram ----\n# Define UI for app that draws a histogram ----\nui &lt;- fluidPage(\n  fluidRow(\n    \n    tabsetPanel(id = \"tabset\",\n                tabPanel(\"Essential\",\n                         fluidRow(\n                           column(4, \n                                  div(style=\"height: 80px;\",sliderInput('r1intab1', 'Supply R1', 1.4, min = 0.1, max = 1.8)),\n                                  div(style=\"height: 80px;\",sliderInput('r2intab1', 'Supply R2', 1.1, min = 0.1, max = 1.8))\n                           ),\n                           column(4,\n                                  div(style=\"height: 80px;\", sliderInput('mu11tab1', HTML(\"&mu;&lt;sub&gt;11&lt;/sub&gt;\"), 1.5, min = 0.1, max = 2)),\n                                  div(style=\"height: 80px;\",sliderInput('mu12tab1', HTML(\"&mu;&lt;sub&gt;12&lt;/sub&gt;\"), 0.4, min = 0.1, max = 2))\n                           ),\n                           column(4,\n                                  div(style=\"height: 80px;\",sliderInput('mu21tab1', HTML(\"&mu;&lt;sub&gt;21&lt;/sub&gt;\"), 0.4, min = 0.1, max = 2)),\n                                  div(style=\"height: 80px;\",sliderInput('mu22tab1', HTML(\"&mu;&lt;sub&gt;22&lt;/sub&gt;\"), 1.25, min = 0.1, max = 2))\n                           )\n                         ),\n                         \n                         fluidRow(\n                           column(4,\n                                  div(style=\"height: 80px;\", sliderInput('mtab1', HTML(\"m\"), 0.2, min = 0.1, max = 1))\n                           ),\n                           column(4,\n                                  div(style=\"height: 80px;\", sliderInput('q11', HTML(\"Q&lt;sub&gt;11&lt;/sub&gt;\"), 1.5, min = 0.1, max = 3)),\n                                  div(style=\"height: 80px;\",sliderInput('q12', HTML(\"Q&lt;sub&gt;12&lt;/sub&gt;\"), 2.6, min = 0.1, max = 3))\n                           ),\n                           column(4,\n                                  div(style=\"height: 80px;\",sliderInput('q21', HTML(\"Q&lt;sub&gt;21&lt;/sub&gt;\"), 2.5, min = 0.1, max = 3)),\n                                  div(style=\"height: 80px;\",sliderInput('q22', HTML(\"Q&lt;sub&gt;22&lt;/sub&gt;\"), 1.1, min = 0.1, max = 3))\n                           )\n                         )\n                ),\n                tabPanel(\"Substitutable\",\n                         fluidRow(\n                           column(4, \n                                  div(style=\"height: 80px;\",sliderInput('r1intab2', 'Supply R1', 0.84, min = 0.1, max = 1.8)),\n                                  div(style=\"height: 80px;\",sliderInput('r2intab2', 'Supply R2', 1.1, min = 0.1, max = 1.8))\n                           ),\n                           column(4,\n                                  div(style=\"height: 80px;\", sliderInput('mu11tab2', HTML(\"&mu;&lt;sub&gt;11&lt;/sub&gt;\"), 1.5, min = 0.1, max = 2)),\n                                  div(style=\"height: 80px;\",sliderInput('mu12tab2', HTML(\"&mu;&lt;sub&gt;12&lt;/sub&gt;\"), 0.4, min = 0.1, max = 2))\n                           ),\n                           column(4,\n                                  div(style=\"height: 80px;\",sliderInput('mu21tab2', HTML(\"&mu;&lt;sub&gt;21&lt;/sub&gt;\"), 0.4, min = 0.1, max = 2)),\n                                  div(style=\"height: 80px;\",sliderInput('mu22tab2', HTML(\"&mu;&lt;sub&gt;22&lt;/sub&gt;\"), 1.25, min = 0.1, max = 2))\n                           )\n                         ),\n                         \n                         fluidRow(\n                           column(4,\n                                  div(style=\"height: 80px;\", sliderInput('mtab2', HTML(\"m\"), 0.5, min = 0.1, max = 1))\n                           ),\n                           column(4,\n                                  div(style=\"height: 80px;\", sliderInput('v11', HTML(\"V&lt;sub&gt;11&lt;/sub&gt;\"), 2.5, min = 0.1, max = 3)),\n                                  div(style=\"height: 80px;\",sliderInput('v12', HTML(\"V&lt;sub&gt;12&lt;/sub&gt;\"), 1.6, min = 0.1, max = 3))\n                           ),\n                           column(4,\n                                  div(style=\"height: 80px;\",sliderInput('v21', HTML(\"V&lt;sub&gt;21&lt;/sub&gt;\"), 1, min = 0.1, max = 3)),\n                                  div(style=\"height: 80px;\",sliderInput('v22', HTML(\"V&lt;sub&gt;22&lt;/sub&gt;\"), 2.1, min = 0.1, max = 3))\n                           )\n                         )\n                )\n    )),\n  \n  fluidRow(\n    column(12, \n           plotlyOutput(\"plot\", width=700, height = 400)\n    ))\n  \n)\n\nserver &lt;- function(input, output, session) {\n\n  \n  \n  output$plot &lt;- renderPlotly({\n    \n      if (input$tabset == \"Essential\") {\n        \n        # sim lv model\n        sim_result_ess &lt;- reactive({\n          Sim_rc_ess(100, input$mu11tab1, input$mu12tab1, input$mu21tab1, input$mu22tab1,\n                     input$q11, input$q12, input$q21, input$q22,\n                     input$r1intab1, input$r2intab1, 0.1, 0.1, input$r1intab1, input$r2intab1, input$mtab1)\n        })\n        \n        R1_1 &lt;-reactive({\n          input$mtab1 / input$mu11tab1 \n        })\n        \n        R2_1 &lt;-reactive({\n          input$mtab1 / input$mu21tab1 \n        })\n        \n        R1_2 &lt;-reactive({\n          input$mtab1 / input$mu12tab1 \n        })\n        \n        \n        R2_2 &lt;- reactive({\n          input$mtab1 / input$mu22tab1\n        })\n        \n        \n        \n        \n        R_star &lt;- data.frame(R1_star = c(rep(R1_1(), 100), seq(R1_1(), 10, length.out=100)),\n                             yrange1 = c(seq(R1_2(), 10, length.out=100), rep(R1_2(), 100)),\n                             R2_star = c(rep(R2_1(), 100), seq(R2_1(), 10, length.out=100)),\n                             yrange2 = c(seq(R2_2(), 10, length.out=100), rep(R2_2(), 100)))\n        \n        \n        p &lt;- plot_ly(data = R_star) %&gt;%\n          add_trace(x = ~R1_star, y = ~yrange1, type = 'scatter', mode = 'lines', name = 'dN1/dt = 0', line = list(color=\"#1c3144\", width = 3)) %&gt;%\n          add_trace(x = ~R2_star, y = ~yrange2, type = 'scatter', mode = 'lines', name = 'dN2/dt = 0', line = list(color = '#d00000', width = 3))\n        \n        if((R1_1() - R2_1()) * (R1_2() - R2_2()) &lt; 0){\n          R_eq_x &lt;- max(R1_1(), R2_1())\n          R_eq_y &lt;- max(R1_2(), R2_2())\n          \n          arrows1 &lt;- reactive({data.frame(start_x = c(R_eq_x),\n                                         start_y = c(R_eq_y),\n                                         end_x = c(R_eq_x * 0.7),\n                                         end_y = c(R_eq_y - (R_eq_x - R_eq_x * 0.7) * input$q12 * R_eq_y / (input$q11 * R_eq_x ) ))})\n          \n          arrows2 &lt;- reactive({data.frame(start_x = c(R_eq_x),\n                                          start_y = c(R_eq_y),\n                                          end_x = c(R_eq_x * 0.7),\n                                          end_y = c(R_eq_y - (R_eq_x - R_eq_x * 0.7) * input$q22 * R_eq_y / (input$q21  * R_eq_x) ))})\n          \n          arrows1expend &lt;- reactive({data.frame(x = seq(R_eq_x, 4, length.out = 100),\n                                                y = c(R_eq_y - (R_eq_x - seq(R_eq_x, 4, length.out = 100)) * input$q12 * R_eq_y / (input$q11 * R_eq_x )))})\n          \n          arrows2expend &lt;- reactive({data.frame(x = seq(R_eq_x, 4, length.out = 100),\n                                                y = c(R_eq_y - (R_eq_x - seq(R_eq_x, 4, length.out = 100)) * input$q22 * R_eq_y / (input$q21  * R_eq_x)))})\n          \n          \n          p &lt;- p %&gt;% add_trace(x = R_eq_x, y = R_eq_y, type = 'scatter', mode = 'markers',\n                               name = 'Equilibrium', marker = list(color=\"black\", size = 10)) %&gt;%\n            add_trace(x = ~x, y = ~y, type = 'scatter', mode = 'lines', name = 'Impact 1', line = list(color=\"#1c3144\", width = 3, dash = 'dash'),\n                      data = arrows1expend()) %&gt;%\n            add_trace(x = ~x, y = ~y, type = 'scatter', mode = 'lines', name = 'Impact 2', line = list(color = '#d00000', width = 3, dash = 'dash'),\n                      data = arrows2expend()) %&gt;%\n            add_annotations(x = ~end_x,\n                            y = ~end_y,\n                            xref = \"x\", yref = \"y\",\n                            axref = \"x\", ayref = \"y\",\n                            text = \"\",\n                            showarrow = T,\n                            ax = ~start_x,\n                            ay = ~start_y,\n                            arrowcolor='#1c3144',\n                            data = arrows1()) %&gt;%\n            add_annotations(x = ~end_x,\n                            y = ~end_y,\n                            xref = \"x\", yref = \"y\",\n                            axref = \"x\", ayref = \"y\",\n                            text = \"\",\n                            showarrow = T,\n                            ax = ~start_x,\n                            ay = ~start_y,\n                            arrowcolor='#d00000',\n                            data = arrows2())\n          p &lt;- p %&gt;% add_trace(x =~R1, y =~R2, type = 'scatter', mode = 'lines+markers', name = 'Trajectory', \n                               marker = list(color = ~cc, size =10), line = list(color = 'grey', width = 4), data = sim_result_ess())\n        }\n        \n      } else {\n        \n        # sim lv model\n        sim_result_sub &lt;- reactive({\n          Sim_rc_sub(100, input$mu11tab2, input$mu12tab2, input$mu21tab2, input$mu22tab2,\n                     input$v11, input$v12, input$v21, input$v22,\n                     input$r1intab2, input$r2intab2, 0.1, 0.1, input$r1intab2, input$r2intab2, input$mtab2)\n        })\n        \n        R1 &lt;- seq(0, 20, 0.01)\n        \n        R2_1 &lt;-reactive({\n          (input$mtab2 - input$mu11tab2 * R1) / input$mu12tab2 \n        })\n        \n        \n        R2_2 &lt;- reactive({\n          (input$mtab2 - input$mu21tab2 * R1) / input$mu22tab2 \n        })\n        \n        R_star &lt;- data.frame(R1 = R1, R2_1 = R2_1(), R2_2 = R2_2())\n        \n        # solve the linear equations\n        A &lt;- matrix(c(input$mu11tab2, input$mu21tab2, input$mu12tab2, input$mu22tab2), 2, 2)\n        b &lt;- c(input$mtab2, input$mtab2)\n        sol &lt;- solve(A, b)\n        R_eq_x &lt;- sol[1]\n        R_eq_y &lt;- sol[2]\n        \n        p &lt;- plot_ly(data = R_star) %&gt;%\n          add_trace(x = ~R1, y = ~R2_1, type = 'scatter', mode = 'lines', name = 'dN1/dt = 0', line = list(color=\"#1c3144\", width = 3)) %&gt;%\n          add_trace(x = ~R1, y = ~R2_2, type = 'scatter', mode = 'lines', name = 'dN2/dt = 0', line = list(color=\"#d00000\", width = 3))\n        \n        if(sol[1]&gt;0 & sol[2]&gt;0){\n          arrows1 &lt;- reactive({data.frame(start_x = c(R_eq_x),\n                                          start_y = c(R_eq_y),\n                                          end_x = c(R_eq_x * 0.7),\n                                          end_y = c(R_eq_y - (R_eq_x - R_eq_x * 0.7) * input$v12 * R_eq_y / (input$v11 * R_eq_x) ))})\n          \n          arrows2 &lt;- reactive({data.frame(start_x = c(R_eq_x),\n                                          start_y = c(R_eq_y),\n                                          end_x = c(R_eq_x * 0.7),\n                                          end_y = c(R_eq_y - (R_eq_x - R_eq_x * 0.7) * input$v22 * R_eq_y / (input$v21 * R_eq_x)))})\n          \n          \n          arrows1expend &lt;- reactive({data.frame(x = seq(R_eq_x, 4, length.out = 100),\n                                                y = c(R_eq_y - (R_eq_x - seq(R_eq_x, 4, length.out = 100)) * input$v12 * R_eq_y / (input$v11 * R_eq_x)))})\n          \n          arrows2expend &lt;- reactive({data.frame(x = seq(R_eq_x, 4, length.out = 100),\n                                                y = c(R_eq_y - (R_eq_x - seq(R_eq_x, 4, length.out = 100)) * input$v22 * R_eq_y / (input$v21 * R_eq_x)))})\n          \n          \n          p &lt;- p %&gt;% add_trace(x = R_eq_x, y = R_eq_y, type = 'scatter', mode = 'markers',\n                               name = 'Equilibrium', marker = list(color=\"black\", size = 10)) %&gt;%\n            add_trace(x = ~x, y = ~y, type = 'scatter', mode = 'lines', name = 'Impact 1', line = list(color=\"#1c3144\", width = 3, dash = 'dash'),\n                      data = arrows1expend()) %&gt;%\n            add_trace(x = ~x, y = ~y, type = 'scatter', mode = 'lines', name = 'Impact 2', line = list(color = '#d00000', width = 3, dash = 'dash'),\n                      data = arrows2expend()) %&gt;%\n            add_annotations(x = ~end_x,\n                            y = ~end_y,\n                            xref = \"x\", yref = \"y\",\n                            axref = \"x\", ayref = \"y\",\n                            text = \"\",\n                            showarrow = T,\n                            ax = ~start_x,\n                            ay = ~start_y,\n                            arrowcolor='#1c3144',\n                            data = arrows1()) %&gt;%\n            add_annotations(x = ~end_x,\n                            y = ~end_y,\n                            xref = \"x\", yref = \"y\",\n                            axref = \"x\", ayref = \"y\",\n                            text = \"\",\n                            showarrow = T,\n                            ax = ~start_x,\n                            ay = ~start_y,\n                            arrowcolor='#d00000',\n                            data = arrows2())\n          \n          p &lt;- p %&gt;% add_trace(x =~R1, y =~R2, type = 'scatter', mode = 'lines+markers', name = 'Trajectory', \n                               marker = list(color =~cc, size =10), line = list(color = 'grey', width = 4), data = sim_result_sub())\n        }\n      }\n\n      \n      \n      # xlim\n      p &lt;- p %&gt;% layout(xaxis = list(range = c(0, 2)),\n                        yaxis = list(range = c(0, 2)))\n      \n      # x label\n      p &lt;- p %&gt;% layout(xaxis = list(title = \"R1\"), yaxis = list(title = \"R2\"))\n      \n      \n      \n      \n      p\n      \n    })\n  \n}\n# Create Shiny app ----\nshinyApp(ui = ui, server = server)\nFor the substitutable resource model, you can play with the model by switching the tab to “Substitutable”."
  },
  {
    "objectID": "posts/02-2024/RCSeminar2014.html",
    "href": "posts/02-2024/RCSeminar2014.html",
    "title": "02 – Lotka-Volterra competition model and the modern coexistence theory",
    "section": "",
    "text": "Two-species Lotka-Volterra competition model and the modern coexistence theory are discussed.\n\nMaterials\nThe video record of the seminar can be found HERE.\nThe Mathematica notebook is HERE.\nThe slides can be found HERE.\n\n\nTwo-species Lotka-Volterra competition model\nThe two-species Lotka-Volterra competition model is defined as\n\\[\n\\begin{aligned}\n\\frac{dN_1}{dt} &=  \\left(r_1 - \\alpha_{11} N_1 - \\alpha_{12} N_2\\right) N_1 \\\\\n\\frac{dN_2}{dt} &=  \\left(r_2 - \\alpha_{21} N_1 - \\alpha_{22} N_2\\right) N_2\n\\end{aligned}\n\\]\nwhere \\(N_1\\) and \\(N_2\\) are the population sizes of species 1 and 2, respectively, \\(r_1\\) and \\(r_2\\) are the intrinsic growth rates, and \\(\\alpha_{ij}\\)s are the competition coefficients.\nFive types of outcomes are possible:\n\nCase 1: Species 1 wins\nIf \\(r_1 / \\alpha_{11} &gt; r_2 / \\alpha_{21}\\) and \\(r_1 / \\alpha_{12} &gt; r_2 / \\alpha_{22}\\), species 1 will win. The ecosystem will reach equilibrium at \\((r_1 / \\alpha_{11}, 0)\\).\nCase 2: Species 2 wins\nIf \\(r_1 / \\alpha_{11} &lt; r_2 / \\alpha_{21}\\) and \\(r_1 / \\alpha_{12} &lt; r_2 / \\alpha_{22}\\), species 2 will win. The ecosystem will reach equilibrium at \\((0, r_2 / \\alpha_{22})\\).\nCase 3: Coexistence\nIf \\(r_1 / \\alpha_{11} &lt; r_2 / \\alpha_{21}\\) and \\(r_1 / \\alpha_{12} &gt; r_2 / \\alpha_{22}\\), the two species will coexist. The equilibrium point is given by the solution of the following equations:\n\\[\nr_1 - \\alpha_{11} N_1 - \\alpha_{12} N_2 =0 \\\\\nr_2 - \\alpha_{21} N_1 - \\alpha_{22} N_2 =0\n\\]\nCase 4: Founder control\nIf \\(r_1 / \\alpha_{11} &gt; r_2 / \\alpha_{21}\\) and \\(r_1 / \\alpha_{12} &lt; r_2 / \\alpha_{22}\\), the species with a larger density at the initial stage will win. The ecosystem will reach equilibrium at the corresponding species’ equilibrium point.\nCase 5: Neutrality\nIf the two species share all parameters, their zero-net-population-isoclines (ZNGIs) are overlapping.\n\n\n\nThe phase-plane analysis\nThe zero-net growth isoclines are given by:\n\\[\n\\begin{aligned}\n\\frac{dN_1}{dt} &= 0 \\Rightarrow N_1 = \\frac{\\left(r_1 - \\alpha_{12} N_2\\right)}{\\alpha_{11}}  \\\\\n\\frac{dN_2}{dt} &= 0 \\Rightarrow N_2 = \\frac{\\left(r_2 - \\alpha_{21} N_1\\right)}{\\alpha_{22}}\n\\end{aligned}\n\\]\nPlot the isoclines in the phase plane.\nThe equilibrium points are the intersection of the isoclines.\n#| standalone: true\n#| viewerHeight: 700\n#| viewerWidth: 1000\n\nlibrary(shiny)\nlibrary(bslib)\nlibrary(plotly)\nlibrary(Matrix)\n\nSim_lotka_volterra &lt;- function(tt, alpha11, alpha12, alpha21, alpha22, r1, r2, N10, N20) {\n  N1 &lt;- c(N10)\n  N2 &lt;- c(N20)\n  for(ti in 1:tt){\n    dN1 &lt;- (r1 - alpha11 * N1[ti] - alpha12 * N2[ti]) * N1[ti]\n    dN2 &lt;- (r2 - alpha21 * N1[ti] - alpha22 * N2[ti]) * N2[ti]\n    N1 &lt;- c(N1, N1[ti] + dN1)\n    N2 &lt;- c(N2, N2[ti] + dN2)\n  }\n  return(data.frame(N1 = N1, N2 = N2))\n  \n}\n\n\n# Define UI for app that draws a histogram ----\n# Define UI for app that draws a histogram ----\nui &lt;- fluidPage(\n  headerPanel(''),\n  \n  fluidRow(\n    column(12, \n           textOutput(\"text\"),\n           tags$head(tags$style(\"#text{color: black;\n                                 font-size: 30px;\n                                 font-style: italic;\n                                 }\"\n           )\n           ),\n           plotlyOutput(\"plot\", width=860)\n    )\n  ), \n  \n  fluidRow(\n    column(4, \n           div(style=\"height: 80px;\",sliderInput('r1', 'r1', 0.4, min = 0.1, max = 3)),\n           div(style=\"height: 80px;\",sliderInput('r2', 'r2', 1.1, min = 0.1, max = 3))\n    ),\n    column(4,\n           div(style=\"height: 80px;\", sliderInput('alpha11', HTML(\"&alpha;&lt;sub&gt;11&lt;/sub&gt;\"), 1.5, min = 0.1, max = 5)),\n           div(style=\"height: 80px;\",sliderInput('alpha12', HTML(\"&alpha;&lt;sub&gt;12&lt;/sub&gt;\"), 0.8, min = 0.1, max = 5))\n    ),\n    column(4,\n           div(style=\"height: 80px;\",sliderInput('alpha21', HTML(\"&alpha;&lt;sub&gt;21&lt;/sub&gt;\"), 0.9, min = 0.1, max = 5)),\n           div(style=\"height: 80px;\",sliderInput('alpha22', HTML(\"&alpha;&lt;sub&gt;22&lt;/sub&gt;\"), 1.1, min = 0.1, max = 5))\n    )\n  )\n  \n  \n)\n\nserver &lt;- function(input, output, session) {\n  N1 &lt;- seq(0, 20, 0.01)\n  N2_1 &lt;-reactive({\n    (input$r1 - input$alpha11 * N1) / input$alpha12 \n  })\n  \n  N2_2 &lt;- reactive({\n    (input$r2 - input$alpha21 * N1) / input$alpha22\n  })\n\n  \n  # sim lv model\n  sim_result &lt;- reactive({\n    Sim_lotka_volterra(100, input$alpha11, input$alpha12, input$alpha21, input$alpha22, input$r1, input$r2, 0.1, 0.1)\n  })\n  \n  output$text &lt;- renderText({\n    if(input$r1 / input$alpha11 &gt; input$r2 / input$alpha21 & input$r1 / input$alpha12 &gt;  input$r2 / input$alpha22){HTML(\"Case 1: Species 1 wins\")}\n    else if(input$r1 / input$alpha11 &lt; input$r2 / input$alpha21 & input$r1 / input$alpha12 &lt;  input$r2 / input$alpha22){\"Case 2: Species 2 wins\"}\n    else if(input$r1 / input$alpha11 &lt; input$r2 / input$alpha21 & input$r1 / input$alpha12 &gt;  input$r2 / input$alpha22){\"Case 3: Coexistence\"}\n    else if(input$r1 / input$alpha11 &gt; input$r2 / input$alpha21 & input$r1 / input$alpha12 &lt;  input$r2 / input$alpha22){\"Case 4: Founder control\"}\n    else {\"Case 5: Neutrality\"}\n    \n  })\n  \n  output$plot &lt;- renderPlotly({\n    Ns &lt;- data.frame(N1 = N1, N2_1 = N2_1(), N2_2 = N2_2())\n    pos_Ns &lt;- Ns[Ns$N2_1 &gt;= 0 | Ns$N2_2 &gt;= 0,]\n    x_lim &lt;- c(0, max(pos_Ns$N1) + 1)\n    y_lim &lt;- c(0, max(pos_Ns$N2_1, pos_Ns$N2_2)+1)\n    p &lt;- plot_ly(x = N1, y = N2_1(), type = 'scatter', mode = 'lines', name = 'dN1/dt = 0') %&gt;%\n      add_trace(x = N1, y = N2_2(), type = 'scatter', mode = 'lines', name = 'dN2/dt = 0') %&gt;%\n      add_trace(x = -1, y = -1, type = 'scatter', mode = 'markers', name = 'Stable equilibrium point',\n                marker = list(color = 'rgb(0, 0, 0)', size = 10, line = list(color = 'rgb(0, 0, 0)',\n                                                                             width = 1\n                ))) %&gt;%\n      add_trace(x = -2, y = -1, type = 'scatter', mode = 'markers', name = 'Unstable equilibrium point',\n                marker = list(color = 'rgb(255, 255, 255)', size = 10, line = list(color = 'rgb(0, 0, 0)',\n                                                                             width = 1\n                ))) %&gt;%\n      add_trace(x = sim_result()$N1, y = sim_result()$N2, type = 'scatter', mode = 'lines+markers', name = 'Trajectory', \n                marker = list(color = 'grey'), line = list(color = 'grey')) %&gt;%\n      add_trace(x = 0.1, y=0.1, type = 'scatter', mode = 'markers', name = 'Initial condition',\n                marker = list(color = 'rgb(0, 0, 0)', size = 5, line = list(color = 'rgb(0, 0, 0)',\n                                                                             width = 1\n                )))\n    \n    if(input$r1 / input$alpha11 &gt; input$r2 / input$alpha21 & input$r1 / input$alpha12 &gt;  input$r2 / input$alpha22){\n      p &lt;- p %&gt;%\n        add_trace(x = input$r1 / input$alpha11, y = 0, type = 'scatter', mode = 'markers', name = 'Stable equilibrium point',\n                  marker = list(color = 'rgb(0, 0, 0)', size = 10, line = list(color = 'rgb(0, 0, 0)',\n                                                                               width = 1\n                  )), showlegend = FALSE) %&gt;%\n        add_trace(x = 0, y = input$r2 / input$alpha22, type = 'scatter', mode = 'markers', name = 'Unstable equilibrium point',\n                  marker = list(color = 'rgb(255, 255, 255)', size = 10, line = list(color = 'rgb(0, 0, 0)',\n                                                                               width = 1\n                  )), showlegend = FALSE) %&gt;%\n        add_trace(x = 0, y = 0, type = 'scatter', mode = 'markers', name = 'Unstable equilibrium point',\n                  marker = list(color = 'rgb(255, 255, 255)', size = 10, line = list(color = 'rgb(0, 0, 0)',\n                                                                                     width = 1\n                  )), showlegend = FALSE) %&gt;%\n        layout(xaxis = list(title = 'N1', range = x_lim), yaxis = list(title = 'N2', range = y_lim))\n    } else if(input$r1 / input$alpha11 &lt; input$r2 / input$alpha21 & input$r1 / input$alpha12 &lt;  input$r2 / input$alpha22){\n\n        p &lt;- p %&gt;%\n          add_trace(x = input$r1 / input$alpha11, y = 0, type = 'scatter', mode = 'markers', name = '',\n                  marker = list(color = 'rgb(255, 255, 255)', size = 10, line = list(color = 'rgb(0, 0, 0)',\n                                                                               width = 1\n                  )), showlegend = FALSE) %&gt;%\n        add_trace(x = 0, y = input$r2 / input$alpha22, type = 'scatter', mode = 'markers', name = '',\n                  marker = list(color = 'rgb(0, 0, 0)', size = 10, line = list(color = 'rgb(0, 0, 0)',\n                                                                               width = 1\n                  )), showlegend = FALSE) %&gt;%\n        add_trace(x = 0, y = 0, type = 'scatter', mode = 'markers', name = '',\n                  marker = list(color = 'rgb(255, 255, 255)', size = 10, line = list(color = 'rgb(0, 0, 0)',\n                                                                                     width = 1\n                  )), showlegend = FALSE) %&gt;%\n        layout(xaxis = list(title = 'N1', range = x_lim), yaxis = list(title = 'N2', range = y_lim))\n    } else if(input$r1 / input$alpha11 &lt; input$r2 / input$alpha21 & input$r1 / input$alpha12 &gt;  input$r2 / input$alpha22){\n      sol &lt;- reactive({solve(matrix(c(input$alpha11, input$alpha21, input$alpha12, input$alpha22), 2, 2), c(input$r1, input$r2))})\n      \n      p &lt;- p %&gt;%\n        add_trace(x = sol()[1], y = sol()[2], type = 'scatter', mode = 'markers', name = '',\n                       marker = list(color = 'rgb(0, 0, 0)', size = 10, line = list(color = 'rgb(0, 0, 0)',\n                                                                                    width = 1\n                       )), showlegend = FALSE) %&gt;%\n        add_trace(x = input$r1 / input$alpha11, y = 0, type = 'scatter', mode = 'markers', name = '',\n                  marker = list(color = 'rgb(255, 255, 255)', size = 10, line = list(color = 'rgb(0, 0, 0)',\n                                                                                     width = 1\n                  )), showlegend = FALSE) %&gt;%\n        add_trace(x = 0, y = input$r2 / input$alpha22, type = 'scatter', mode = 'markers', name = '',\n                  marker = list(color = 'rgb(255, 255, 255)', size = 10, line = list(color = 'rgb(0, 0, 0)',\n                                                                               width = 1\n                  )), showlegend = FALSE) %&gt;%\n        add_trace(x = 0, y = 0, type = 'scatter', mode = 'markers', name = '',\n                  marker = list(color = 'rgb(255, 255, 255)', size = 10, line = list(color = 'rgb(0, 0, 0)',\n                                                                                     width = 1\n                  )), showlegend = FALSE) %&gt;%\n        layout(xaxis = list(title = 'N1', range = x_lim), yaxis = list(title = 'N2', range = y_lim))\n      \n    } else if(input$r1 / input$alpha11 &gt; input$r2 / input$alpha21 & input$r1 / input$alpha12 &lt;  input$r2 / input$alpha22){\n      sol &lt;- reactive({solve(matrix(c(input$alpha11, input$alpha21, input$alpha12, input$alpha22), 2, 2), c(input$r1, input$r2))})\n      \n      p &lt;- p %&gt;%\n        add_trace(x = sol()[1], y = sol()[2], type = 'scatter', mode = 'markers', name = '',\n                  marker = list(color = 'rgb(255, 255, 255)', size = 10, line = list(color = 'rgb(0, 0, 0)',\n                                                                               width = 1\n                  )), showlegend = FALSE) %&gt;%\n        add_trace(x = input$r1 / input$alpha11, y = 0, type = 'scatter', mode = 'markers', name = '',\n                  marker = list(color = 'rgb(0, 0, 0)', size = 10, line = list(color = 'rgb(0, 0, 0)',\n                                                                               width = 1\n                  )), showlegend = FALSE) %&gt;%\n        add_trace(x = 0, y = input$r2 / input$alpha22, type = 'scatter', mode = 'markers', name = '',\n                  marker = list(color = 'rgb(0, 0, 0)', size = 10, line = list(color = 'rgb(0, 0, 0)',\n                                                                                     width = 1\n                  )), showlegend = FALSE) %&gt;%\n        add_trace(x = 0, y = 0, type = 'scatter', mode = 'markers', name = '',\n                  marker = list(color = 'rgb(255, 255, 255)', size = 10, line = list(color = 'rgb(0, 0, 0)',\n                                                                                     width = 1\n                  )), showlegend = FALSE) %&gt;%\n        layout(xaxis = list(title = 'N1', range = x_lim), yaxis = list(title = 'N2', range = y_lim))\n    } else {\n      p &lt;- p %&gt;%\n        layout(xaxis = list(title = 'N1', range = x_lim), yaxis = list(title = 'N2', range = y_lim))\n    }\n    \n    p\n  })\n  \n}\n# Create Shiny app ----\nshinyApp(ui = ui, server = server)\n\n\nThe stability of the equilibrium points\nConsider a small perturbation from an equilibrium.\nCalculate eigenvalues \\(\\lambda\\) of Jacobian matrix \\(J\\) evaluated at an equilibrium \\((N_1^*, N_2^*)\\):\n\\[\nJ = \\left.\\begin{pmatrix}\n\\frac{\\partial f_1}{\\partial N_1} & \\frac{\\partial f_1}{\\partial N_2} \\\\\n\\frac{\\partial f_2}{\\partial N_1} & \\frac{\\partial f_2}{\\partial N_2}\n\\end{pmatrix}\\right|_{(N_1^*, N_2^*)}\n\\]\nwhere \\(f_1 = \\left(r_1 - \\alpha_{11} N_1 - \\alpha_{12} N_2\\right) N_1\\) and \\(f_2 = \\left(r_2 - \\alpha_{21} N_1 - \\alpha_{22} N_2\\right) N_2\\). The eigenvalues of the Jacobian matrix determine the stability of the equilibrium points.\n\nStable equilibrium\nIf the eighenvalues have negative real parts, the equilibrium point is stable.\nUnstable equilibrium\nIf any eighenvalue has positive real parts, the equilibrium point is unstable.\nStability analysis failure\nIf largest eigenvalue is 0, linear stability analysis fails (possibly neutral).\n\n\n\nInvasion analysis\nThe invasion analysis is used to determine the outcome of the competition between two species.\nIf any species can invade a community when the other species is at equilibrium, the two species can stably coexist.\nThe invasion rate of Species \\(i\\) is defined as the per capita growth rate when rare while Species \\(j\\) is at equilibrium:\n\\[\n\\lambda_{ij} = \\left.\\frac{1}{N_i} \\frac{dN_i}{dt}\\right|_{N_j^*,N_i=0}\n\\]\nSpecies \\(j\\) reaches equilibrium at \\(N_j^*=r_j / \\alpha_{jj}\\) on its own. So, the invasion rate of Species \\(i\\) yields:\n\\[\n\\lambda_{ij} = r_i - \\frac{\\alpha_{ij}}{\\alpha_{jj}} r_j\n\\]\nSo, the rule is to examine the sign of \\(\\lambda_{ij}\\) and \\(\\lambda_{ji}\\).\n\nCase 1: Species 1 wins\nIf \\(\\lambda_{12} &gt; 0\\) and \\(\\lambda_{21} &lt; 0\\), species 1 outcompetes species 2.\nCase 2: Species 2 wins\nIf \\(\\lambda_{12} &lt; 0\\) and \\(\\lambda_{21} &gt; 0\\), species 2 outcompetes species 1.\nCase 3: Coexistence\nIf \\(\\lambda_{12} &gt; 0\\) and \\(\\lambda_{21} &gt; 0\\), the two species can stably coexist (“mutual invasibility”).\nCase 4: Founder control\nIf \\(\\lambda_{12} &lt; 0\\) and \\(\\lambda_{21} &lt; 0\\), it is founder control.\n\n\n\nModern coexistence theory\nPeter Chesson (e.g. 2000, 2020) developed the modern coexistence theory based on the Lotka-Volterra competition model. Two key concepts, niche differences and fitness differences, are derived from the invasion criterion.\nBased on the invasion criterion, stable coexistence is achieved if and only if the two species are “mutually invasible”:\n\\[\n\\lambda_{12} &gt; 0 \\text{ and } \\lambda_{21} &gt; 0\n\\]\nwhich are:\n\\[\nr_1 - \\frac{\\alpha_{12}}{\\alpha_{22}} r_2 &gt; 0 \\text{ and } r_2 - \\frac{\\alpha_{21}}{\\alpha_{11}} r_1 &gt; 0.\n\\]\nSo,\n\\[\n\\frac{\\alpha_{12}}{\\alpha_{22}} &lt; \\frac{r_1}{r_2} &lt; \\frac{\\alpha_{11}}{\\alpha_{21}}.\n\\]\nAfter symmetrizing the inequality, we have\n\\[\n\\sqrt\\frac{\\alpha_{12}\\alpha_{21}}{\\alpha_{11}\\alpha_{22}} &lt; \\sqrt\\frac{\\alpha_{12}\\alpha_{22}}{\\alpha_{11}\\alpha_{21}} \\frac{r_1}{r_2} &lt; \\sqrt\\frac{\\alpha_{11}\\alpha_{22}}{\\alpha_{12}\\alpha_{21}} .\n\\]\nwhich can be simplified as\n\\[\n\\frac{1}{\\rho} &lt; \\delta &lt; \\rho\n\\]\nwhere \\(\\rho = \\sqrt\\frac{\\alpha_{11}\\alpha_{22}}{\\alpha_{12}\\alpha_{21}}\\) and \\(\\delta = \\sqrt\\frac{\\alpha_{12}\\alpha_{22}}{\\alpha_{11}\\alpha_{21}} \\frac{r_1}{r_2}\\).\n\\(\\rho\\) is then interpreted as the “niche overlap” and \\(\\delta\\) as the “fitness difference”.\nThis crieteria then seperates the space of the niche overlap and fitness difference into four regions:\n\n\n\nniche overlap and fitness difference\n\n\n\n\nLotka-Volterra competition model: Pros & Cons\n\nPros\n\nAnalytically tractable: The model is simple and can be solved analytically;\nGraphical approach: Easy to do the graphical analysis based on the zero-net-growth isoclines;\nSimple and clear outcomes of competition. For example, 5 outcomes of competition can be derived from two-species cases;\nPhenomenological: The model can be used to describe the competition between two species in a simple way.\n\nCons\n\nLinear competitive effects: higher order interactions are ignored;\nNo physical meaning to parameters: The parameters in the model have no physical meaning;\nHow does competitive outcome depend on environmental gradients? The analysis relies on constant parameters. Thus, the model is not suitable for studying the competition along environmental gradients;\nCurse of dimensionality: The model and the analysis are not suitable for studying the competition among more than two species.\nHow are parameters related / constrained? The model does not provide any information on how the parameters are related or constrained.\n\n\n\n\nReferences\nBarabás G, D’Andrea R, Stump SM (2018) Chesson’s coexistence theory. Ecological Monographs 88: 277– 303.\nChesson P (2000) Mechanisms of maintenance of species diversity. Annual Review of Ecology, Evolution, and Systematics 31: 343–366\nChesson P (2020) Species coexistence. In: Theoretical Ecology. Oxford University Press, pp 5–27 Gause GF, Witt AA (1935) Behavior of mixed populations and the problem of natural selection. American Naturalist 69: 596–609\nGrainger TN, Levine JM, Gilbert B (2019) The invasion criterion: a common currency for ecological research. Trends in Ecology & Evolution 34: 925–935.\nKingsland S (1995) Modeling Nature: Episodes in the History of Population Ecology. 2nd edition.\nMallet J (2012) The struggle for existence: how the notion of carrying capacity, K, obscures the links between demography, Darwinian evolution, and speciation. Evolutionary Ecology Research 14: 627–655\nMetz JAJ, Nisbet RM, Geritz SAH (1992) How should we define “fitness” for general ecological scenarios. Trends in Ecology & Evolution 7: 198–202"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "This seminar is organised by Christopher Klausmeier as the form of an online seminar on resource competition theory and related ecological theories from January 8th to April 15th 2024. The format is a mix of lectures and discussion of classic and recent papers. Some previous exposure to ecological theories and an intro grad level (e.g. population growth models & competition theory) is desired.\nThis blog is developed and maintained by Liang Xu, severing as an online lecture and providing an alternative to the programming illustration by Mathematica for those who cannot access Mathematica. The blog is developed using Quarto and hosted on GitHub. The interactive visulation of the model is implemented using R Shiny. If you have any questions or suggestions, or would like to help, make corrections, please feel free to contact me via Email"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Resource Competition Seminar 2024",
    "section": "",
    "text": "06 – Variable environment and the storage (Droop) model\n\n\n\n\n\n\nPaper Discussion\n\n\n\n\n\n\n\n\n\nFeb 29, 2024\n\n\nChristopher Klausmeier; Liang Xu\n\n\n\n\n\n\n\n\n\n\n\n\n05 – The resource-consumer competition model\n\n\n\n\n\n\nPaper Discussion\n\n\n\n\n\n\n\n\n\nFeb 22, 2024\n\n\nChristopher Klausmeier; Liang Xu\n\n\n\n\n\n\n\n\n\n\n\n\n04 – The resource-consumer competition model\n\n\n\n\n\n\nLectures\n\n\n\n\n\n\n\n\n\nFeb 15, 2024\n\n\nChristopher Klausmeier; Liang Xu\n\n\n\n\n\n\n\n\n\n\n\n\n03 – The three-species problem\n\n\n\n\n\n\nPaper Discussion\n\n\n\n\n\n\n\n\n\nFeb 8, 2024\n\n\nChristopher Klausmeier; Liang Xu\n\n\n\n\n\n\n\n\n\n\n\n\n02 – Lotka-Volterra competition model and the modern coexistence theory\n\n\n\n\n\n\nLectures\n\n\n\n\n\n\n\n\n\nFeb 1, 2024\n\n\nChristopher Klausmeier; Liang Xu\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/03-2024/RCSeminar2014-03.html",
    "href": "posts/03-2024/RCSeminar2014-03.html",
    "title": "03 – The three-species problem",
    "section": "",
    "text": "Paper discussion: The three-species problem: incorporating competitive asymmetry and intransitivity in modern coexistence theory by Ravi Ranjan, Thomas Koffel, Christopher A. Klausmeier. (Link to the paper will be added soon)\n\nMaterials\nThe Mathematica notebook is HERE.\n\n\nPaper discussion\nWe talked about the three species competition. There are many types of competition outcomes. They are determined by the 12 parameters in the model, i.e., the three intrinsic growth rates and 9 pairwise competition coefficients. The authors showed that the outcome of the competition is associated with the cyclic asymmetry, which is a triplet-wise quantity.\n\nPaper Abstract\nWhile natural communities can contain hundreds of species, modern coexistence theory focuses primarily on species pairs. Alternatively, the structural stability approach considers the feasibility of equilibria, gaining scalability to larger communities but sacrificing information about dynamic stability. Three-species competitive communities are a bridge to more-diverse communities. They display novel phenomena while remaining amenable to mathematical analysis, but remain incompletely understood. Here, we combine these approaches to identify the key quantities that determine the outcome of competition. We show that pairwise niche overlap and fitness differences are insufficient to completely characterize competitive outcomes, which requires a strictly triplet-wise quantity: cyclic asymmetry. Low pairwise niche overlap stabilizes the triplet, while high fitness differences promote competitive exclusion. The effect of cyclic asymmetry on stability is complex and depends on pairwise niche overlap. In summary, we elucidate how pairwise niche overlap, fitness differences, and cyclic asymmetry determine the outcome of three-species competition.\n\n\n\n\nCoexistence of three species\n\n\n\n\nModel\nThe three-species Lotka-Volterra competition model is defined as\n\\[\n\\begin{aligned}\n\\frac{dN_1}{dt} &=  \\left(r_1 - \\alpha_{11} N_1 - \\alpha_{12} N_2 - \\alpha_{13} N_3\\right) N_1 \\\\\n\\frac{dN_2}{dt} &=  \\left(r_2 - \\alpha_{21} N_1 - \\alpha_{22} N_2 - \\alpha_{23} N_3\\right) N_2 \\\\\n\\frac{dN_3}{dt} &=  \\left(r_3 - \\alpha_{31} N_1 - \\alpha_{32} N_2 - \\alpha_{33} N_3\\right) N_3\n\\end{aligned}\n\\]\nwhere \\(N_1\\), \\(N_2\\) and \\(N_3\\) are the population sizes of species 1, 2 and 3, respectively, \\(r_1\\), \\(r_2\\) and \\(r_3\\) are the intrinsic growth rates, and \\(\\alpha_{ij}\\)s are the competition coefficients.\n\n\nThe simulation\n#| standalone: true\n#| viewerHeight: 700\n#| viewerWidth: 1000\n\nlibrary(shiny)\nlibrary(bslib)\nlibrary(plotly)\nlibrary(Matrix)\n\nSim_lotka_volterra &lt;- function(tt, alpha11, alpha12, alpha13, alpha21, alpha22,\n                               alpha23, alpha31, alpha32, alpha33, r1, r2, r3, N10, N20, N30) {\n  N1 &lt;- c(N10)\n  N2 &lt;- c(N20)\n  N3 &lt;- c(N30)\n  cc &lt;- c(0)\n  for(ti in 1:tt){\n    dN1 &lt;- (r1 - alpha11 * N1[ti] - alpha12 * N2[ti] - alpha13 * N3[ti]) * N1[ti]\n    dN2 &lt;- (r2 - alpha21 * N1[ti] - alpha22 * N2[ti] - alpha23 * N3[ti]) * N2[ti]\n    dN3 &lt;- (r3 - alpha31 * N1[ti] - alpha32 * N2[ti] - alpha33 * N3[ti]) * N3[ti]\n    N1 &lt;- c(N1, N1[ti] + dN1)\n    N2 &lt;- c(N2, N2[ti] + dN2)\n    N3 &lt;- c(N3, N3[ti] + dN3)\n    cc &lt;- c(cc, ti)\n  }\n  return(data.frame(N1 = N1, N2 = N2, N3 = N3, cc = cc))\n  \n}\n\n\n\n\n# Define UI for app that draws a histogram ----\n# Define UI for app that draws a histogram ----\nui &lt;- fluidPage(\n  headerPanel(''),\n  \n  fluidRow(\n    column(12, \n           tags$head(tags$style(\"#text{color: black;\n                                 font-size: 30px;\n                                 font-style: italic;\n                                 }\"\n           )\n           ),\n           plotlyOutput(\"plot\", width=860)\n    )\n  ), \n  \n  fluidRow(\n    column(3, \n           div(style=\"height: 80px;\",sliderInput('r1', 'r1', 1.1, min = 0.1, max = 3)),\n           div(style=\"height: 80px;\",sliderInput('r2', 'r2', 1.1, min = 0.1, max = 3)),\n           div(style=\"height: 80px;\",sliderInput('r3', 'r3', 1.1, min = 0.1, max = 3))\n    ),\n    column(3,\n           div(style=\"height: 80px;\", sliderInput('alpha11', HTML(\"&alpha;&lt;sub&gt;11&lt;/sub&gt;\"), 1.0, min = 0.1, max = 5)),\n           div(style=\"height: 80px;\",sliderInput('alpha12', HTML(\"&alpha;&lt;sub&gt;12&lt;/sub&gt;\"), 0.15, min = 0.1, max = 5)),\n           div(style=\"height: 80px;\",sliderInput('alpha13', HTML(\"&alpha;&lt;sub&gt;13&lt;/sub&gt;\"), 1.9, min = 0.1, max = 5))\n    ),\n    column(3,\n           div(style=\"height: 80px;\",sliderInput('alpha21', HTML(\"&alpha;&lt;sub&gt;21&lt;/sub&gt;\"), 2, min = 0.1, max = 5)),\n           div(style=\"height: 80px;\",sliderInput('alpha22', HTML(\"&alpha;&lt;sub&gt;22&lt;/sub&gt;\"), 1.1, min = 0.1, max = 5)),\n           div(style=\"height: 80px;\",sliderInput('alpha23', HTML(\"&alpha;&lt;sub&gt;23&lt;/sub&gt;\"), 0.2, min = 0.1, max = 5))\n    ),\n    column(3,\n           div(style=\"height: 80px;\",sliderInput('alpha31', HTML(\"&alpha;&lt;sub&gt;31&lt;/sub&gt;\"), 0.15, min = 0.1, max = 5)),\n           div(style=\"height: 80px;\",sliderInput('alpha32', HTML(\"&alpha;&lt;sub&gt;32&lt;/sub&gt;\"), 2.1, min = 0.1, max = 5)),\n           div(style=\"height: 80px;\",sliderInput('alpha33', HTML(\"&alpha;&lt;sub&gt;33&lt;/sub&gt;\"), 1.2, min = 0.1, max = 5))\n    )\n  )\n  \n  \n)\n\nserver &lt;- function(input, output, session) {\n  N1 &lt;- seq(0, 20, 0.01)\n  N2_1 &lt;-reactive({\n    (input$r1 - input$alpha11 * N1) / input$alpha12 \n  })\n  \n  N3_1 &lt;-reactive({\n    (input$r1 - input$alpha11 * N1) / input$alpha13 \n  })\n  \n  N2_2 &lt;- reactive({\n    (input$r2 - input$alpha21 * N1) / input$alpha22\n  })\n  \n  \n  # sim lv model\n  sim_result &lt;- reactive({\n    Sim_lotka_volterra(100, input$alpha11, input$alpha12, input$alpha13,\n                       input$alpha21, input$alpha22, input$alpha23,\n                       input$alpha31, input$alpha32, input$alpha33,\n                       input$r1, input$r2, input$r3, 0.1, 0.1, 0.1)\n  })\n  \n  \n  output$plot &lt;- renderPlotly({\n    Ns &lt;- data.frame(N1 = N1, N2_1 = N2_1(), N2_2 = N2_2())\n    pos_Ns &lt;- Ns[Ns$N2_1 &gt;= 0 | Ns$N2_2 &gt;= 0,]\n    x_lim &lt;- c(0, max(pos_Ns$N1) + 1)\n    y_lim &lt;- c(0, max(pos_Ns$N2_1, pos_Ns$N2_2)+1)\n    p &lt;- plot_ly(sim_result(), x = ~N1, y = ~N2, z = ~N3, type = 'scatter3d',  mode = 'lines+markers',\n                 line = list(width = 6,  color = ~cc, colorscale = list(c(0,'#BA52ED'), c(100,'#FCB040'))),\n                 marker = list(size = 3.5, color = '#56A902'),\n                 width = 500, height = 400)\n      \n    # p &lt;- layout(p, scene = list(xaxis = list(range = c(0, 1.5)), yaxis = list(range = c(0, 2)),\n    #                              zaxis = list(range = c(0, 2))))\n    \n    \n    p\n  })\n  \n}\n# Create Shiny app ----\nshinyApp(ui = ui, server = server)\n\n\nReferences\nRavi Ranjan, Thomas Koffel, Christopher A. Klausmeier, The three-species problem: incorporating competitive asymmetry and intransitivity in modern coexistence theory, 2024, in press."
  },
  {
    "objectID": "posts/05-2024/RCSeminar2014-05.html",
    "href": "posts/05-2024/RCSeminar2014-05.html",
    "title": "05 – The resource-consumer competition model",
    "section": "",
    "text": "In this session, we discussed three papers that argued whether the predictions from the resource-ratio theory (equivalently, the resource-consumer theory, the \\(R^*\\) theory) have been adequately evidenced.\n\nMaterials\nThe slides can be found HERE.\nThe Mathematica notebook is HERE.\n\n\nSufficient evidence for the resource-ratio theory?\n\n\n\nResults\n\n\n\n\nReferences\nThomas E. Miller, Jean H. Burns, Pablo Munguia, Eric L. Walters, Jamie M. Kneitel, Paul M. Richards, Nicolas Mouquet, and Hannah L. Buckley. “A Critical Review of Twenty Years’ Use of the Resource‐Ratio Theory.” The American Naturalist 165, no. 4 (2005): 439-48. https://doi.org/10.1086/428681. https://www.journals.uchicago.edu/doi/abs/10.1086/428681.\nWilson JB, Spijkerman E, Huisman J. Is there really insufficient support for Tilman’s R* concept? A comment on Miller et al. Am Nat. 2007 May;169(5):700-6. doi: 10.1086/513113. Epub 2007 Apr 5. PMID: 17427140.\nT. E. Miller, J. H. Burns, P. Munguia, E. L. Walters, J. M. Kneitel, P. M. Richards, N. Mouquet, and H. L. Buckley. “Evaluating Support for the Resource‐Ratio Hypothesis: A Reply to Wilson Et Al.” The American Naturalist 169, no. 5 (2007): 707-08. https://doi.org/10.1086/513110. https://www.journals.uchicago.edu/doi/abs/10.1086/513110."
  }
]